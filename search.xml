<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>本科项目经历</title>
      <link href="/project/experience/"/>
      <url>/project/experience/</url>
      
        <content type="html"><![CDATA[<h2 id="加油"><a href="#加油" class="headerlink" title="加油"></a>加油</h2>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 05 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客Top101 贪心算法总结</title>
      <link href="/06%20Top101%20%E8%B4%AA%E5%BF%83/"/>
      <url>/06%20Top101%20%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h2 id="牛客Top101-贪心算法总结"><a href="#牛客Top101-贪心算法总结" class="headerlink" title="牛客Top101 贪心算法总结"></a>牛客Top101 贪心算法总结</h2>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 06 算法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第13讲：JDK性能监控命令</title>
      <link href="/01%20JVM-ch13/"/>
      <url>/01%20JVM-ch13/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM从入门到精通-第13讲-JDK性能监控命令"><a href="#JVM从入门到精通-第13讲-JDK性能监控命令" class="headerlink" title="JVM从入门到精通 第13讲: JDK性能监控命令"></a>JVM从入门到精通 第13讲: JDK性能监控命令</h1><blockquote><p><strong><font size=4>前言📝</font></strong></p><p>&emsp;&emsp;我们都知道 JVM 在启动的时候会去加载类信息，那么我们怎么得知他加载了哪些类，又卸载了哪些类呢？我们这一节就来介绍四个 JVM 参数，使用它们我们就可以清晰地知道 JVM 的类加载信息。</p><p>&emsp;&emsp;为了方便演示，我们使用下面的程序作为本次的演示程序。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第12讲：JVM参数之GC日志配置</title>
      <link href="/01%20JVM-ch12/"/>
      <url>/01%20JVM-ch12/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM从入门到精通-第12讲-JVM参数之GC日志配置"><a href="#JVM从入门到精通-第12讲-JVM参数之GC日志配置" class="headerlink" title="JVM从入门到精通 第12讲: JVM参数之GC日志配置"></a>JVM从入门到精通 第12讲: JVM参数之GC日志配置</h1><blockquote><p><strong><font size=4>前言📝</font></strong></p><p>&emsp;&emsp;我们都知道 JVM 在启动的时候会去加载类信息，那么我们怎么得知他加载了哪些类，又卸载了哪些类呢？我们这一节就来介绍四个 JVM 参数，使用它们我们就可以清晰地知道 JVM 的类加载信息。</p><p>&emsp;&emsp;为了方便演示，我们使用下面的程序作为本次的演示程序。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第11讲：JVM参数之追踪类信息</title>
      <link href="/01%20JVM-ch11/"/>
      <url>/01%20JVM-ch11/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM从入门到精通-第11讲-JVM参数之追踪类信息"><a href="#JVM从入门到精通-第11讲-JVM参数之追踪类信息" class="headerlink" title="JVM从入门到精通 第11讲: JVM参数之追踪类信息"></a>JVM从入门到精通 第11讲: JVM参数之追踪类信息</h1><blockquote><p><strong><font size=4>前言📝</font></strong></p><p>&emsp;&emsp;我们都知道 JVM 在启动的时候会去加载类信息，那么我们怎么得知他加载了哪些类，又卸载了哪些类呢？我们这一节就来介绍四个 JVM 参数，使用它们我们就可以清晰地知道 JVM 的类加载信息。</p><p>&emsp;&emsp;为了方便演示，我们使用下面的程序作为本次的演示程序。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;chenshuyi&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I&#x27;m &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跟踪类的加载和卸载-verbose-class"><a href="#跟踪类的加载和卸载-verbose-class" class="headerlink" title="跟踪类的加载和卸载 -verbose:class"></a>跟踪类的加载和卸载 -verbose:class</h2><blockquote><p>&emsp;&emsp;我们使用下面的参数运行程序：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -verbose:<span class="keyword">class</span> <span class="title class_">com</span>.chenshuyi.ClassLoadDemo &gt; class_load_info.txt</span><br></pre></td></tr></table></figure><blockquote><p>&emsp;&emsp;之后我们打开 class_load_info.txt 文件。因为该文件太大，所以我们节选一部分：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略</span></span><br><span class="line">[Loaded java.util.ArrayList from /Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_181</span>.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">[Loaded java.util.HashMap from /Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_181</span>.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">[Loaded com.chenshuyi.ClassLoadDemo from file:/Users/yurongchan/Yosemite/Code/practice/target/classes/]</span><br><span class="line"><span class="comment">// 省略</span></span><br></pre></td></tr></table></figure><blockquote><p>&emsp;&emsp;从上面可以看到 JVM 分别加载了 ArrayList、HashMap 类，以及我们自己定义的 ClassLoadDemo 类。</p></blockquote><p><br></p><h2 id="跟踪类的加载-XX-TraceClassLoading"><a href="#跟踪类的加载-XX-TraceClassLoading" class="headerlink" title="跟踪类的加载 -XX:+TraceClassLoading"></a>跟踪类的加载 -XX:+TraceClassLoading</h2><blockquote><p>&emsp;&emsp; 该参数与可以显示类的加载信息，输出的结果和 <code>-verbose:class</code> 一样，但比起它少了类的卸载信息。</p></blockquote><p><br></p><h2 id="跟踪类的卸载-XX-TraceClassUnloading"><a href="#跟踪类的卸载-XX-TraceClassUnloading" class="headerlink" title="跟踪类的卸载 -XX:+TraceClassUnloading"></a>跟踪类的卸载 -XX:+TraceClassUnloading</h2><blockquote><p>&emsp;&emsp;该参数与可以显示类的加载信息，输出的结果和 <code>-verbose:class</code> 一样，但比起它少了类的加载信息。</p><p>&emsp;&emsp;但实际上我们通过上面这个简单的例子，没有发现类的卸载信息，或许是例子太简单了，所以没有这个。</p></blockquote><p><br></p><h2 id="XX-PrintClassHistogram"><a href="#XX-PrintClassHistogram" class="headerlink" title="-XX:+PrintClassHistogram"></a>-XX:+PrintClassHistogram</h2><blockquote><p>&emsp;&emsp;该参数表示遇到 Ctrl-Break 后打印类实例的柱状信息，与 jmap -histo 功能相同。</p></blockquote><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>&emsp;&emsp;了解了这些参数，能够让我们更好地了解哪些类已经被加载到 JVM 中，从而更好地排查问题。</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-verbose:class</td><td style="text-align:center">跟踪类的加载和卸载</td></tr><tr><td style="text-align:center">-XX:+TraceClassLoading</td><td style="text-align:center">跟踪类的加载</td></tr><tr><td style="text-align:center">-XX:+TraceClassUnloading</td><td style="text-align:center">跟踪类的卸载</td></tr><tr><td style="text-align:center">-XX:+PrintClassHistogram</td><td style="text-align:center">显示类信息柱状图</td></tr></tbody></table></div><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第10讲：JVM参数之查看JVM参数</title>
      <link href="/01%20JVM-ch10/"/>
      <url>/01%20JVM-ch10/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM从入门到精通-第10讲-JVM参数之查看JVM参数"><a href="#JVM从入门到精通-第10讲-JVM参数之查看JVM参数" class="headerlink" title="JVM从入门到精通 第10讲: JVM参数之查看JVM参数"></a>JVM从入门到精通 第10讲: JVM参数之查看JVM参数</h1><blockquote><p><strong><font size=4>前言📝</font></strong></p><p>&emsp;&emsp;今天要说的是如何查看 JVM 中已经设置的参数，包括 <code>显示参数</code> 和 <code>隐式参数</code> 。</p></blockquote><h2 id="打印显式参数"><a href="#打印显式参数" class="headerlink" title="打印显式参数"></a>打印显式参数</h2><p>&emsp;&emsp;我们使用 <code>-XX:+PrintVMOptions</code> 打印显式参数。</p><p>&emsp;&emsp;该参数表示程序运行时，打印虚拟机接受到的命令行显式参数。我们用下面的命令运行程序：</p><p>&emsp;&emsp;可以看到我们设置了 <code>+UseSerialGC</code> 和 <code>+PrintVMOptions</code> 两个参数，最后运行时也将这两个参数打印出来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行代码</span></span><br><span class="line">java  -XX:+UseSerialGC -XX:+PrintVMOptions com.chenshuyi.ClassLoadDemo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">VM option <span class="string">&#x27;+UseSerialGC&#x27;</span></span><br><span class="line">VM option <span class="string">&#x27;+PrintVMOptions&#x27;</span></span><br><span class="line">Hello, I<span class="string">&#x27;m chenshuyi</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="打印显式隐式参数"><a href="#打印显式隐式参数" class="headerlink" title="打印显式隐式参数"></a>打印显式隐式参数</h2><p>&emsp;&emsp;我们使用 <code>-XX:+PrintCommandLineFlags</code> 打印显式隐式参数</p><p>&emsp;&emsp;该参数打印传递给虚拟机的显式和隐式参数。我们用下面的命令运行程序：</p><p>&emsp;&emsp;可以看到程序不仅输出了我们显式设置的参数，还将虚拟机默认的参数打印了出来，包括初始堆大小（134217728），最大堆大小（2147483648）等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行代码</span></span><br><span class="line">java  -XX:+UseSerialGC -XX:+PrintCommandLineFlags com.chenshuyi.ClassLoadDemo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">134217728</span> -XX:MaxHeapSize=<span class="number">2147483648</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC</span><br><span class="line">Hello, I<span class="string">&#x27;m chenshuyi</span></span><br></pre></td></tr></table></figure><h2 id="打印所有系统参数"><a href="#打印所有系统参数" class="headerlink" title="打印所有系统参数"></a>打印所有系统参数</h2><p>&emsp;&emsp;我们使用 <code>-XX:+PrintFlagsFinal</code>  打印所有系统参数。</p><p>&emsp;&emsp;该参数会打印所有的系统参数的值。我们用下面的命令运行程序：</p><p>&emsp;&emsp;之后打开 jvm_flag_final.txt 文件，可以看到有 800 多行，这是因为程序将虚拟机的所有参数都打印了出来。下面列几个我们常用的参数看看就可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行代码</span></span><br><span class="line">java  -XX:+UseSerialGC -XX:+PrintFlagsFinal com.chenshuyi.ClassLoadDemo  &gt; jvm_flag_final.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">uintx InitialHeapSize := <span class="number">134217728</span> &#123;product&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uintx</span> <span class="variable">MaxMetaspaceSize</span> <span class="operator">=</span> <span class="number">18446744073709547520</span> &#123;product&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uintx</span> <span class="variable">MetaspaceSize</span> <span class="operator">=</span> <span class="number">21807104</span> &#123;pd product&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;从上面我们列出的部分参数可以看到，上面三个参数分别是设置 <code>初始堆大小、元空间最大大小、初始元空间大小</code>  。</p><ul><li><code>-XX:+PrintVMOptions</code> 程序运行时，打印虚拟机接受到的命令行显式参数。</li><li><code>-XX:+PrintCommandLineFlags</code> 打印传递给虚拟机的显式和隐式参数。</li><li><code>-XX:+PrintFlagsFinal</code> 打印所有的系统参数的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第9讲：JVM参数之堆栈空间配置</title>
      <link href="/01%20JVM-ch09/"/>
      <url>/01%20JVM-ch09/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM从入门到精通-第9讲-JVM参数之堆栈空间配置"><a href="#JVM从入门到精通-第9讲-JVM参数之堆栈空间配置" class="headerlink" title="JVM从入门到精通 第9讲: JVM参数之堆栈空间配置"></a>JVM从入门到精通 第9讲: JVM参数之堆栈空间配置</h1><blockquote><p><strong><font size=4>前言📝</font></strong></p><p>&emsp;&emsp;JVM 中最重要的一部分就是堆空间了，基本上大多数的线上 JVM 问题都是因为堆空间造成的 <code>OutOfMemoryError</code> 。</p><p>&emsp;&emsp;因此掌握 JVM 关于堆空间的参数配置对于排查线上问题非常重要。</p><p>&emsp;&emsp;<font color=#e82e52 size=2><strong>tips：本文所有配置，如无特别说明，均基于JDK1.8。</strong></font></p></blockquote><h2 id="堆配置"><a href="#堆配置" class="headerlink" title="堆配置"></a>堆配置</h2><p>&emsp;&emsp;我们使用 -Xms 设置堆的初始空间大小，使用 -Xmx 设置堆的最大空间大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 JVM 的初始堆大小为 20M，最大堆空间为 30M</span></span><br><span class="line">java -Xms20m -Xmx30m GCDemo</span><br></pre></td></tr></table></figure><h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p>&emsp;&emsp;在 JDK1.8 中，堆分为年轻代和老年代。JVM 提供了参数 <code>-Xmn</code> 来设置年轻代内存的大小，但没有提供参数设置老年代的大小。</p><p>&emsp;&emsp;但其实老年代的大小就等于堆大小减去年轻代大小。可通过 <code>-XX:+PrintGCDetails</code> 参数来查看内存区域的分配情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  设置 JVM 堆初始大小为20M</span></span><br><span class="line"><span class="comment">  其中年轻代的大小为 10M，剩下老年代 10M</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">java -Xms20m -Xmn10M GCDemo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看内存分配情况</span></span><br><span class="line">java -Xms20m -Xmn10M -XX:+PrintGCDetails Hello World</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图中，我们可以看到老年代的大小为 10M。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.clz-blog.top/01%20jvm-img/jvm-09-01.png"/></div></div><p><br></p><h3 id="Eden区"><a href="#Eden区" class="headerlink" title="Eden区"></a>Eden区</h3><p>&emsp;&emsp;在年轻代中，分为三个区域，分别是：eden 空间、from 空间、to 空间。如果要设置这部分的大小，那么就使用 <code>-XX:SurvivorRatio</code> 这个参数，该参数设置 eden / from 空间的比例关系，该参数的公式如下：</p><p>&emsp;&emsp;<code>-XX:SurvivorRatio = eden/from = eden/to</code></p><p>&emsp;&emsp;例如我们的年轻代有 10 M，而我们设置 <code>-XX:SurvivorRatio</code> 参数为 2。也就是说 <code>eden / from = eden / to = 2</code> 。</p><p>&emsp;&emsp;这里教一个快速计算的方法，我们假设 eden = 2，那么 from = 1，to = 1，那么 eden + from + to = 10M。这样就可以算出每一份大小是 10/4 = 2.5M。所以 Eden 区 = 2.5 * 2 = 5M，from 区是 2.5 M，to 区是 2.5 M。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms20m -Xmn10M -XX:SurvivorRatio=<span class="number">2</span> -XX:+PrintGCDetails GCDemo</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图中：eden 空间是 5120 K，from 和 to 空间是 2560 K。</p><p>&emsp;&emsp;还有一个细节，即 PSYoungGen 这里的 total 只有 7680K，难道年轻代只有 7.5M 的内存吗？为什么不是 10M 呢？</p><p>&emsp;&emsp;其实是因为这里的 total 指的是可用内存，from space 和 to space 两个区域，同一时间只有一个区域是可以用的。所以可用内存是 5120 + 2560 = 7680。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.clz-blog.top/01%20jvm-img/jvm-09-02.png"/></div></div><p><br></p><h2 id="永久代（JDK1-7）"><a href="#永久代（JDK1-7）" class="headerlink" title="永久代（JDK1.7）"></a>永久代（JDK1.7）</h2><p>&emsp;&emsp;在 JDK 1.8 之前，所加载的类信息都放在永久代中。</p><ul><li>使用 <code>-XX:PermSize</code> 设置永久代初始大小；</li><li>使用 <code>-XX:MaxPermSize</code> 设置永久代最大大小；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置永久代初始大小为 10M，最大大小为 50M</span></span><br><span class="line">java -XX:PermSize10m -XX:MaxPermSize50m -XX:+PrintGCDetails GCDemo</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图中，我们可以看到永久代的大小为我们设置的 10M</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.clz-blog.top/01%20jvm-img/jvm-09-03.png"/></div></div><p><br></p><h2 id="元空间（JDK1-8）"><a href="#元空间（JDK1-8）" class="headerlink" title="元空间（JDK1.8）"></a>元空间（JDK1.8）</h2><p>&emsp;&emsp;在 JDK 1.8 之前，所有加载的类信息都放在永久代中。但在 JDK1.8 之时，永久代被移除，取而代之的是元空间（Metaspace）。</p><p>&emsp;&emsp;在元空间这块内存中，有两个参数很相似，它们是： <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 MetaspaceSize 为 10M，MaxMetaspaceSize 为 50M</span></span><br><span class="line"><span class="comment">// 并不是设置初始大小和最大大小</span></span><br><span class="line">java -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=50m -XX:+PrintGCDetails GCDemo</span><br></pre></td></tr></table></figure><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.clz-blog.top/01%20jvm-img/jvm-09-04.png"/></div></div><p>&emsp;&emsp;从上面的执行结果可以看到，Metaspace 空间的大小为 2.6M 左右，并不是我们设置的 10M。那是因为 <code>MetaspaceSize</code> 设置的是元空间发生 GC 的初始阈值。<br>&emsp;&emsp;当达到这个值时，元空间发生 GC 操作，这个值默认是 20.8M。而 <code>MaxMetaspaceSize</code> 则是设置元空间的最大大小，默认基本是机器的物理内存大小。虽然可以不设置，但还是建议设置一下，因为如果一直不断膨胀，那么 JVM 进程可能会被 OS kill 掉。</p><h2 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h2><p>&emsp;&emsp;栈空间是每个线程各自有的一块区域，如果栈空间太小，也会导致 <code>StackOverFlow</code> 异常。而要设置栈空间大小，只需要使用 <code>-Xss</code> 参数就可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置最大栈空间为 2M</span></span><br><span class="line">java -Xss2m GCDemo</span><br></pre></td></tr></table></figure><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>&emsp;&emsp;在 JVM 中还有一块内存，它独立于 JVM 的堆内存，它就是：直接内存。我们可以使用 <code>-XX:MaxDirectMemorySize</code> 设置最大直接内存。如果不设置，默认为最大堆空间，即 -Xmx。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置直接内存最大值为 50M</span></span><br><span class="line">java -XX:MaxDirectMemorySize=50m GCDemo</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当直接内存使用达到设置值时，就会触发垃圾回收。如果不能有效释放足够空间，就会引发直接内存溢出导致系统的 OOM。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">Xms</td><td style="text-align:center">初始堆大小</td></tr><tr><td style="text-align:center">-Xmx</td><td style="text-align:center">最大堆空间</td></tr><tr><td style="text-align:center">-Xmn</td><td style="text-align:center">设置新生代大小</td></tr><tr><td style="text-align:center">-XX:SurvivorRatio</td><td style="text-align:center">设置新生代eden空间和from/to空间的比例关系</td></tr><tr><td style="text-align:center">-XX:PermSize</td><td style="text-align:center">方法区初始大小</td></tr><tr><td style="text-align:center">-XX:MaxPermSize</td><td style="text-align:center">方法区最大大小</td></tr><tr><td style="text-align:center">-XX:MetaspaceSize</td><td style="text-align:center">元空间GC阈值（JDK1.8）</td></tr><tr><td style="text-align:center">-XX:MaxMetaspaceSize</td><td style="text-align:center">最大元空间大小（JDK1.8）</td></tr><tr><td style="text-align:center">-Xss</td><td style="text-align:center">栈大小</td></tr><tr><td style="text-align:center">-XX:MaxDirectMemorySize</td><td style="text-align:center">直接内存大小，默认为最大堆空间</td></tr></tbody></table></div><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第8讲：垃圾回收的几种类型</title>
      <link href="/01%20JVM-ch08/"/>
      <url>/01%20JVM-ch08/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM从入门到精通-第8讲-垃圾回收的几种类型"><a href="#JVM从入门到精通-第8讲-垃圾回收的几种类型" class="headerlink" title="JVM从入门到精通 第8讲: 垃圾回收的几种类型"></a>JVM从入门到精通 第8讲: 垃圾回收的几种类型</h2><blockquote><p>&emsp;我们经常会听到许多垃圾回收的术语，例如：Minor GC、Major GC、Young GC、Old GC、Full GC、Stop-The-World 等。但这些 GC 术语到底指的是什么，它们之间的区别到底是什么？今天我们就来详细说说。</p></blockquote><p><br></p><h3 id="1、Minor-GC"><a href="#1、Minor-GC" class="headerlink" title="1、Minor GC"></a>1、Minor GC</h3><blockquote><p>&emsp;从年轻代空间回收内存被称为 Minor GC，有时候也称之为 Young GC。对于 Minor GC，你需要知道的一些点：</p><ul><li>当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以 Eden 区越小，越频繁执行 Minor GC。</li><li>当年轻代中的 Eden 区分配满的时候，年轻代中的部分对象会晋升到老年代，所以 Minor GC 后老年代的占用量通常会有所升高。</li><li>质疑常规的认知，所有的 Minor GC 都会触发 Stop-The-World，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的，因为大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果情况相反，即 Eden 区大部分新生对象不符合 GC 条件（即他们不被垃圾回收器收集），那么 Minor GC 执行时暂停的时间将会长很多（因为他们要JVM要将他们复制到 Survivor 区或老年代）。</li></ul></blockquote><p><br></p><h3 id="2、Major-GC"><a href="#2、Major-GC" class="headerlink" title="2、Major GC"></a>2、Major GC</h3><blockquote><p>&emsp;从老年代空间回收内存被称为 Major GC，有时候也称之为 Old GC。</p><p>&emsp;许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的。</p><p>&emsp;Minor GC 作用于年轻代，Major GC 作用于老年代。 分配对象内存时发现内存不够，触发 Minor GC。Minor GC 会将对象移到老年代中，如果此时老年代空间不够，那么触发 Major GC。因此才会说，许多 Major GC 是由 Minor GC 引起的。</p></blockquote><p><br></p><h3 id="3、Full-GC"><a href="#3、Full-GC" class="headerlink" title="3、Full GC"></a>3、Full GC</h3><blockquote><p>&emsp;Full GC 是清理整个堆空间 —— 包括年轻代、老年代和永久代（如果有的话）。因此 Full GC 可以说是 Minor GC 和 Major GC 的结合。</p><p>&emsp;当准备要触发一次 Minor GC 时，如果发现年轻代的剩余空间比以往晋升的空间小，则不会触发 Minor GC 而是转为触发 Full GC。因为JVM此时认为：之前这么大空间的时候已经发生对象晋升了，那现在剩余空间更小了，那么很大概率上也会发生对象晋升。既然如此，那么我就直接帮你把事情给做了吧，直接来一次 Full GC，整理一下老年代和年轻代的空间。</p><p>&emsp;另外，即在永久代分配空间但已经没有足够空间时，也会触发 Full GC。</p></blockquote><p><br></p><h3 id="4、Stop-The-World"><a href="#4、Stop-The-World" class="headerlink" title="4、Stop-The-World"></a>4、Stop-The-World</h3><blockquote><p>&emsp;Stop-The-World，中文一般翻译为全世界暂停，是指在进行垃圾回收时因为标记或清理的需要，必须让所有执行任务的线程停止执行任务，从而让垃圾回收线程回收垃圾的时间间隔。</p><p>&emsp;在 Stop-The-World 这段时间里，所有非垃圾回收线程都无法工作，都暂停下来。只有等到垃圾回收线程工作完成才可以继续工作。可以看出，Stop-The-World 时间的长短将关系到应用程序的响应时间，因此在 GC 过程中，Stop-The-World 的时间是一个非常重要的指标。</p></blockquote><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.zhihu.com/question/41922036">Minor GC、Major GC和Full GC之间的区别</a></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第7讲：JVM垃圾回收器</title>
      <link href="/01%20JVM-ch07/"/>
      <url>/01%20JVM-ch07/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM从入门到精通-第7讲-JVM垃圾回收器"><a href="#JVM从入门到精通-第7讲-JVM垃圾回收器" class="headerlink" title="JVM从入门到精通 第7讲: JVM垃圾回收器"></a>JVM从入门到精通 第7讲: JVM垃圾回收器</h2><blockquote><p>&emsp;我们介绍了 Java 虚拟机的内存结构，Java 虚拟机的垃圾回收机制，那么这篇文章我们说说具体执行垃圾回收的垃圾回收器。</p><p>&emsp;总的来说，Java 虚拟机的垃圾回收器可以分为四大类别：<font color=red size=2><strong>串行回收器、并行回收器、CMS 回收器、G1 回收器</strong></font> 。</p></blockquote><p><br></p><h3 id="1、串行回收器"><a href="#1、串行回收器" class="headerlink" title="1、串行回收器"></a>1、串行回收器</h3><blockquote><p>&emsp;串行回收器是指使用单线程进行垃圾回收的回收器。因为每次回收时只有一个线程，因此串行回收器在并发能力较弱的计算机上，其专注性和独占性的特点往往能让其有更好的性能表现。</p><p>&emsp;串行回收器可以在新生代和老年代使用，根据作用于不同的堆空间，分为新生代串行回收器和老年代串行回收器。</p></blockquote><p><br></p><p>&emsp;<font color=red size=3><strong>新生代串行回收器</strong></font> </p><blockquote><p>&emsp;串行收集器是所有垃圾回收器中最古老的一种，也是 JDK 中最基本的垃圾回收器之一。</p><p>&emsp;在新生代串行回收器中使用的是复制算法。在串行回收器进行垃圾回收时，会触发 Stop-The-World 现象，即其他线程都需要暂停，等待垃圾回收完成。因此在某些情况下，其会造成较为糟糕的用户体验。</p><p>&emsp;使用 <code>-XX:+UseSerialGC</code> 参数可以指定使用新生代串行收集器和老年代串行收集器。当虚拟机在 Client 模式下运行时，其默认使用该垃圾收集器。</p></blockquote><p><br></p><p>&emsp;<font color=red size=3><strong>老年代串行回收器</strong></font> </p><blockquote><p>&emsp;在老年代串行回收器中使用的是标记压缩算法。其与新生代串行收集器一样，只能串行、独占式地进行垃圾回收，因此也经常会有较长时间的 Stop-The-World 发生。</p><p>&emsp;但老年代串行回收器的好处之一，就是其可以与多种新生代回收器配合使用。若要启用老年代串行回收器，可以尝试以下参数：</p><ul><li><code>-XX:UseSerialGC</code>：新生代、老年代都使用串行回收器。</li><li><code>-XX:UseParNewGC</code>：新生代使用 ParNew 回收器，老年代使用串行回收器。</li><li><code>-XX:UseParallelGC</code>：新生代使用 ParallelGC 回收器，老年代使用串行回收器。</li></ul></blockquote><p><br></p><h3 id="2、并行回收器"><a href="#2、并行回收器" class="headerlink" title="2、并行回收器"></a>2、并行回收器</h3><blockquote><p>&emsp;并行回收器在串行回收器的基础上做了改进，其使用多线程进行垃圾回收。对于并行能力强的机器，可以有效缩短垃圾回收所使用的时间。</p><p>&emsp;根据作用内存区域的不同，并行回收器也有三个不同的回收器：新生代 ParNew 回收器、新生代 ParallelGC 回收器、老年代 ParallelGC 回收器。</p></blockquote><p><br></p><p>&emsp;<font color=red size=3><strong>新生代 ParNew 回收器</strong></font> </p><blockquote><p>&emsp;新生代 ParNew 回收器工作在新生代，其只是简单地将串行回收器多线程化，其回收策略、算法以及参数和新生代串行回收器一样。</p><p>&emsp;新生代 ParNew 回收器同样使用复制的垃圾回收算法，其垃圾收集过程中同样会触发 Stop-The-World 现象。但因为其使用多线程进行垃圾回收，因此在并发能力强的 CPU 上，其产生的停顿时间要短于串行回收器。</p><p>&emsp;但在单 CPU 或并能能力弱的系统中，并行回收器效果会因为线程切换的原因，其实际表现反而不如串行回收器。</p><p>&emsp;要开启新生代 ParNew 回收器，可以使用以下参数：</p><ul><li>-XX:+UseParNewGC：新生代使用 ParNew 回收器，老年代使用串行回收器。</li><li>-XX:UseConcMarkSweepGC：新生代使用 ParNew 回收器，老年代使用 CMS。</li><li>-XX:ParallelGCThreads：指定 ParNew 回收器的工作线程数量。</li></ul></blockquote><p><br></p><p>&emsp;<font color=red size=3><strong>新生代 Parallel GC 回收器</strong></font> </p><blockquote><p>&emsp;新生代 Parallel GC 回收器与新生代 ParNew 回收器非常类似，其也是使用复制算法，都是多线程、独占式的收集器，也会导致 Stop-The-World。但其余 ParNew 回收器的一个重大不同是：其非常注重系统的吞吐量。</p><p>&emsp;之所以说新生代 Parallel GC 回收器非常注重系统吞吐量，是因为其有一个自适应 GC 调节策略。我们可以使用 <code>-XX:+UseAdaptiveSizePolicy</code> 参数打开这个策略，在这个模式下，新生代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数都会被自动调节，已达到堆大小、吞吐量、停顿时间的平衡点。</p><p>&emsp;Parallel GC 回收器提供了两个重要参数用于控制系统的吞吐量。</p><ul><li><code>-XX:MaxGCPauseMillis</code>：设置最大垃圾收集停顿时间。在 ParallelGC 工作时，其会自动调整响应参数，将停顿时间控制在设置范围内。为了达到目的，其可能会使用较小的堆，但这会导致 GC 较为频繁。</li><li><code>-XX:GCTimeRatio</code>：设置吞吐量大小，其实一个 0 - 100 的整数。假设 GCTimeRatio 的值为 n，那么系统将不花费超过 1/(1+n) 的时间用于垃圾手机。比如 GCTimeRatio 值为 19，那么系统用于垃圾收集的时间不超过 1 /(1+19) = 5%。默认情况下，它的取值是 99，即不超过 1% 的时间用于垃圾收集。</li></ul><p>&emsp;新生代 Parallel GC 回收器可以使用以下参数启用：</p><ul><li><code>-XX:+UseParallelGC</code>：新生代使用 Parallel 回收器，老年代使用串行回收器。</li><li><code>-XX:+UseParallelOldGC</code>：新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器。</li></ul></blockquote><p><br></p><p>&emsp;<font color=red size=3><strong>老年代 ParallelOldGC 回收器</strong></font> </p><blockquote><p>&emsp;老年代 ParallelOldGC 回收器也是一种多线程并发的回收器，与新生代 ParallelGC 收集器一样，其也是注重吞吐量的收集器，只不过其是作用于老年代。</p><p>&emsp;ParallelOldGC 回收器使用的是标记压缩算法，只有在 JDK 1.6 中才可以使用。我们可以使用 <code>-XX:UseParallelOldGC</code> 参数在新生代中使用 ParallelGC 收集器，在老年代中使用 ParallelOldGC 收集器。参数 <code>-XX:ParallelGCThreads</code>也可以用于设置垃圾回收时的线程数量。</p></blockquote><p><br></p><h3 id="3、CMS-回收器"><a href="#3、CMS-回收器" class="headerlink" title="3、CMS 回收器"></a>3、CMS 回收器</h3><blockquote><p>&emsp;与 ParallelGC 和 ParallelOldGC 不同，CMS 回收器主要关注系统停顿时间。CMS 回收器全称为 Concurrent Mark Sweep，意为标记清除算法，其是一个使用多线程并行回收的垃圾回收器。</p></blockquote><p><br></p><p>&emsp;<font color=red size=3><strong>工作步骤</strong></font> </p><blockquote><p>&emsp;CMS 的主要工作步骤有：初始标记、并发标记、预清理、重新标记、并发清除和并发充值。其中初始标记和重新标记是独占系统资源的，而其他阶段则可以和用户线程一起执行。</p><p>&emsp;在整个 CMS 回收过程中，默认情况下会有预清理的操作，我们可以关闭开关 <code>-XX:-CMSPrecleaningEnabled</code> 不进行预清理。因为重新标记是独占 CPU 的，因此如果新生代 GC 发生之后，立刻出发一次新生代 GC，那么停顿时间就会很长。为了避免这种情况，预处理时会刻意等待一次新生代 GC 的发生，之后在进行预处理。</p></blockquote><p><br></p><p>&emsp;<font color=red size=3><strong>主要参数</strong></font> </p><blockquote><p>&emsp;启动 CMS 回收器刻意使用参数：<code>-XX:+UseConcMarkSweepGC</code> ，线程并发数量刻意通过 <code>-XX:ConcGCThreads</code> 或 <code>-XX:ParallelCMSThreads</code> 参数设定。</p><p>&emsp;此外，我们还可以设置 <code>-XX:CMSInitiatingOccupancyFraction</code> 来指定老年代空间使用阈值。当老年代空间使用率达到这个阈值时，会执行一次 CMS 回收，而不像其他回收器一样等到内存不够用的时候才进行 GC。</p><p>&emsp;我们之前说过标记清除算法的缺点是会产生内存碎片，因此 CMS 回收器会产生较多内存碎片。我们可以使用 <code>XX:+UseCMSCompactAtFullCollection</code> 参数让 CMS 在完成垃圾回收后，进行一次内存碎片整理。使用 <code>-XX:CMSFullGCsBeforeCompaction</code> 参数设置进行多少次 CMS 回收后，进行一次内存压缩。</p><p>&emsp;此外，如果希望使用 CMS 回收 Perm 区，那么则可以打开 <code>-XX:+CMSClassUnloadingEnabled</code> 开关。打开该开关后，如果条件允许，那么系统会使用 CMS 的机制回收 Perm 区 Class 数据。</p></blockquote><p><br></p><h3 id="4、G1-回收器"><a href="#4、G1-回收器" class="headerlink" title="4、G1 回收器"></a>4、G1 回收器</h3><blockquote><p>&emsp;G1 回收器是 JDK 1.7 中使用的全新垃圾回收器，从长期目标来看，其是为了取代 CMS 回收器。</p><p>&emsp;G1 回收器拥有独特的垃圾回收策略，和之前所有垃圾回收器采用的垃圾回收策略不同。从分代看，G1 依然属于分代垃圾回收器。但它最大的改变是使用了分区算法，从而使得 Eden 区、From 区、Survivor 区和老年代等各块内存不必连续。</p><p>&emsp;在 G1 回收器之前，所有的垃圾回收器其内存分配都是连续的一块内存，如下图所示。</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.clz-blog.top//01%20jvm-img/jvm%2005-01.png"/></div></div><blockquote><p>&emsp;而在 G1 回收器中，其将一大块的内存分为许多细小的区块，从而不要求内存是连续的。</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.clz-blog.top//01%20jvm-img/jvm%2005-02.png"/></div></div><blockquote><p>&emsp;从上图可以看到，每个Region被标记了 E、S、O 和 H，说明每个 Region 在运行时都充当了一种角色。所有标记为 E 的都是 Eden 区的内存，它们散落在内存的各个角落，并不要求内存连续。同理，Survivor 区、老年代（Old）也是如此。</p><p>&emsp;从上图我们还可以看到 H 是以往算法中没有的，它代表 Humongous。这表示这些 Region 存储的是巨型对象（humongous object，H-obj），当新建对象大小超过 Region 大小一半时，直接在新的一个或多个连续 Region 中分配，并标记为 H。</p><p>&emsp;堆内存中一个 Region 的大小可以通过 -XX:G1HeapRegionSize 参数指定，大小区间只能是1M、2M、4M、8M、16M 和 32M，总之是2的幂次方。如果G1HeapRegionSize 为默认值，即把设置的最小堆内存按照2048份均分，最后得到一个合理的大小。</p></blockquote><p><br></p><p>&emsp;<font color=red size=3><strong>工作步骤</strong></font> </p><blockquote><p>&emsp;G1 收集器的收集过程主要有四个阶段：</p><ul><li>新生代 GC</li><li>并发标记周期</li><li>混合收集</li><li>如果需要，可能进行 FullGC</li></ul><p>&emsp;新生代 GC 与其他垃圾收集器的类似，就是清空 Eden 区，将存活对象移动到 Survivor 区，部分年龄到了就移动到老年代。</p><p>&emsp;并发标记周期则分为：初始标记、根区域扫描、并发标记、重新标记、独占清理、并发清理阶段。其中初始标记、重新标记、独占清理是独占式的，会引起停顿。并且初始标记会引发一次新生代 GC。在这个阶段，所有将要被回收的区域会被 G1 记录在一个称之为 Collection Set 的集合中。</p><p>&emsp;混合回收阶段会首先针对 Collection Set 中的内存进行回收，因为这些垃圾比例较高。G1 回收器的名字 Garbage First 就是这个意思，垃圾优先处理的意思。在混合回收的时候，也会执行多次新生代 GC 和 混合 GC，从而来进行内存的回收。</p><p>&emsp;必要时进行 Full GC。当在回收阶段遇到内存不足时，G1 会停止垃圾回收并进行一次 Full GC，从而腾出更多空间进行垃圾回收。</p></blockquote><p><br></p><p>&emsp;<font color=red size=3><strong>相关参数</strong></font> </p><blockquote><p>&emsp;打开 G1 收集器，我们可以使用参数：`-XX:+UseG1GC。</p><p>&emsp;设置目标最大停顿时间，可以使用参数：-XX:MaxGCPauseMillis。</p><p>&emsp;设置 GC 工作线程数量，可以使用参数：-XX:ParallelGCThreads。</p><p>&emsp;设置堆使用率触发并发标记周期的执行，可以使用参数：-XX:InitiatingHeapOccupancyPercent。</p></blockquote><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><blockquote><p>&emsp;从一开始的串行回收器，到后来的并行回收器、CMS回收器，到最后的 G1 回收器，垃圾回收器不断改进，使得垃圾回收效率不断提升。特别是分区思想诞生后，对于垃圾回收停顿时间的控制更加细腻，可以让应用有更完美的延时控制，从而呈现更好的用户体验。</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.clz-blog.top//01%20jvm-img/jvm%2005-03.png"/></div></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第6讲：JVM 垃圾回收机制</title>
      <link href="/01%20JVM-ch06/"/>
      <url>/01%20JVM-ch06/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM从入门到精通-第6讲-JVM-垃圾回收机制"><a href="#JVM从入门到精通-第6讲-JVM-垃圾回收机制" class="headerlink" title="JVM从入门到精通 第6讲: JVM 垃圾回收机制"></a>JVM从入门到精通 第6讲: JVM 垃圾回收机制</h2><blockquote><p>&emsp;在 Java 虚拟机的内存结构，提到了这部分的规范其实是由《Java 虚拟机规范》指定的，每个 Java 虚拟机可能都有不同的实现。其实涉及到 Java 虚拟机的内存，就不得不谈到 Java 虚拟机的垃圾回收机制。因为内存总是有限的，我们需要一个机制来不断地回收废弃的内存，从而实现内存的循环利用，这样程序才能正常地运转下去。</p><p>&emsp;比起 Java 虚拟机的内存结构有《Java 虚拟机规范》规定，垃圾回收机制并没有具体的规范约束。所以很多时候不同的虚拟机有不同的实现方式，下面所说的垃圾回收都是以 HotSpot 虚拟机为例。</p></blockquote><p><br></p><h3 id="1、到底谁是垃圾？"><a href="#1、到底谁是垃圾？" class="headerlink" title="1、到底谁是垃圾？"></a>1、到底谁是垃圾？</h3><blockquote><p>&emsp;要进行垃圾回收，最为重要的一个问题是：判断谁是垃圾？</p><p>&emsp;联想其日常生活中，如果一个东西经常没被使用，那么这个对象可以说就是垃圾。在 Java 中也是如此，如果一个对象不可能再被引用，那么这个对象就是垃圾，应该被回收。</p><p>&emsp;根据这个思想，我们很容易想到使用引用计数的方法来判断垃圾。在一个对象被引用时加一，被去除引用时减一，这样我们就可以通过判断引用计数是否为零来判断一个对象是否为垃圾。这种方法我们一般称之为 <code>引用计数法</code> 。</p><p>&emsp;上面的这种方法虽然简单，但是其存在一个致命的问题，那就是 <strong>循环引用</strong> 。</p><p>&emsp;A 引用了 B，B 引用了 C，C 引用了 A，它们各自的引用计数都为 1。但是它们三个对象却从未被其他对象引用，只有它们自身互相引用。从垃圾的判断思想来看，它们三个确实是不被其他对象引用的，但是此时它们的引用计数却不为零。这就是引用计数法存在的循环引用问题。</p><p>&emsp;而现今的 Java 虚拟机判断垃圾对象使用的是：<code>GC Root Tracing 算法</code>  。其大概的过程是这样：从 GC Root 出发，所有可达的对象都是存活的对象，而所有不可达的对象都是垃圾。</p><p>&emsp;可触达的进一步分为：强引用、弱引用、软引用、虚引用。</p><p>&emsp;可以看到这里最重要的就是 GC Root 这个集合了，其实 GC Root 就是一组活跃引用的集合。但是这个集合又与一般的对象集合不太一样，这些集合是经过特意筛选出来的，通常包括：</p><ul><li>所有当前被加载的 Java 类;</li><li>Java 类的引用类型静态变量;</li><li>Java类的运行时常量池里的引用类型常量;</li><li>VM的一些静态数据结构里指向GC堆里的对象的引用;</li></ul><p>&emsp;简单地说，GC Root 就是经过精心挑选的一组活跃引用，这些引用是肯定存活的。那么通过这些引用延伸到的对象，自然也是存活的。</p></blockquote><p><br></p><h3 id="2、如何进行垃圾回收？"><a href="#2、如何进行垃圾回收？" class="headerlink" title="2、如何进行垃圾回收？"></a>2、如何进行垃圾回收？</h3><blockquote><p>&emsp;到这里，我们了解了什么是垃圾以及 JVM 是如何判断垃圾对象的。那么识别出垃圾对象之后，JVM 是如何进行垃圾回收的呢？这就是我们下面要讲的内容：如何进行垃圾回收？</p><p>&emsp;垃圾回收算法简单地说有三种算法：标记清除算法、复制算法、标记压缩算法。</p><p>&emsp;标记清除算法。从名字可以看到其分为两个阶段：标记阶段和清除阶段。一种可行的实现方式是，在标记阶段，标记所有由 GC Root 触发的可达对象。此时，所有未被标记的对象就是垃圾对象。之后在清除阶段，清除所有未被标记的对象。标记清除算法最大的问题就是空间碎片问题。如果空间碎片过多，则会导致内存空间的不连续。虽说大对象也可以分配在不连续的空间中，但是效率要低于连续的内存空间。</p><p>&emsp;复制算法。复制算法的核心思想是将原有的内存空间分为两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收。该算法的缺点是要将内存空间折半，极大地浪费了内存空间。</p><p>&emsp;标记压缩算法。标记压缩算法可以说是标记清除算法的优化版，其同样需要经历两个阶段，分别是：标记结算、压缩阶段。在标记阶段，从 GC Root 引用集合触发去标记所有对象。在压缩阶段，其则是将所有存活的对象压缩在内存的一边，之后清理边界外的所有空间。</p><p>&emsp;对比一下这三种算法，可以发现他们都有各自的优点和缺点。</p><p>&emsp;标记清除算法虽然会产生内存碎片，但是不需要移动太多对象，比较适合在存活对象比较多的情况。而复制算法虽然需要将内存空间折半，并且需要移动存活对象，但是其清理后不会有空间碎片，比较适合存活对象比较少的情况。而标记压缩算法，则是标记清除算法的优化版，减少了空间碎片。</p></blockquote><p><br></p><h3 id="3、分代思想"><a href="#3、分代思想" class="headerlink" title="3、分代思想"></a>3、分代思想</h3><blockquote><p>&emsp;试想一下，如果我们单独采用任何一种算法，那么最终的垃圾回收效率都不会很好。其实 JVM 虚拟机的建造者们也是这么想的，因此在实际的垃圾回收算法中采用了分代算法。</p><p>&emsp;所谓分代算法，就是根据 JVM 内存的不同内存区域，采用不同的垃圾回收算法。例如对于存活对象少的新生代区域，比较适合采用复制算法。这样只需要复制少量对象，便可完成垃圾回收，并且还不会有内存碎片。而对于老年代这种存活对象多的区域，比较适合采用标记压缩算法或标记清除算法，这样不需要移动太多的内存对象。</p><p>&emsp;试想一下，如果没有采用分代算法，而在老年代中使用复制算法。在极端情况下，老年代对象的存活率可以达到100%，那么我们就需要复制这么多个对象到另外一个内存区域，这个工作量是非常庞大的。</p><p>&emsp;在这里我们再深入地聊一聊新生代里采取的垃圾回收算法。如我们上面所说，新生代的特点是存活对象少，适合采用复制算法。而复制算法的一种最简单实现便是折半内存使用，另一半备用。但实际上我们知道，在实际的 JVM 新生代划分中，却不是采用等分为两块内存的形式。而是分为：Eden 区域、from 区域、to 区域 这三个区域。那么为什么 JVM 最终要采用这种形式，而不用 50% 等分为两个内存块的方式？</p><p>&emsp;要解答这个问题，我们就需要先深入了解新生代对象的特点。根据IBM公司的研究表明，在新生代中的对象 98% 是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间。所以在HotSpot虚拟机中，JVM 将内存划分为一块较大的Eden空间和两块较小的Survivor空间，其大小占比是8:1:1。当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Eden空间。</p><p>&emsp;通过这种方式，内存的空间利用率达到了90%，只有10%的空间是浪费掉了。而如果通过均分为两块内存，则其内存利用率只有 50%，两者利用率相差了将近一倍。</p></blockquote><p><br></p><h3 id="4、分区思想"><a href="#4、分区思想" class="headerlink" title="4、分区思想"></a>4、分区思想</h3><blockquote><p>&emsp;分代思想按照对象的生命周期长短将其分为了两个部分（新生代、老年代），但 JVM 中其实还有一个分区思想，即将整个堆空间划分成连续的不同小区间。</p><p>&emsp;每一个小区间都独立使用，独立回收，这种算法的好处是可以控制一次回收多少个区间，可以较好地控制 GC 时间。</p><p>&emsp;到这里我们基本上把 JVM 的垃圾回收都将清除了，从一开始什么是垃圾，到之后如何判断垃圾，到如何回收垃圾，到垃圾回收的两个重要思想：分代思想、分区思想。通过这么一个脉络，我们了解了垃圾回收的整体概括。在下面的章节中，我们将深入介绍这其中的细节。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第5讲：JVM 类加载机制</title>
      <link href="/01%20JVM-ch05/"/>
      <url>/01%20JVM-ch05/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM从入门到精通-第5讲-JVM-类加载机制"><a href="#JVM从入门到精通-第5讲-JVM-类加载机制" class="headerlink" title="JVM从入门到精通 第5讲: JVM 类加载机制"></a>JVM从入门到精通 第5讲: JVM 类加载机制</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第4讲：Java 虚拟机内存结构</title>
      <link href="/01%20JVM-ch04/"/>
      <url>/01%20JVM-ch04/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM从入门到精通-第4讲-Java-虚拟机内存结构"><a href="#JVM从入门到精通-第4讲-Java-虚拟机内存结构" class="headerlink" title="JVM从入门到精通 第4讲: Java 虚拟机内存结构"></a>JVM从入门到精通 第4讲: Java 虚拟机内存结构</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第3讲：字节码文件结构</title>
      <link href="/01%20JVM-ch03/"/>
      <url>/01%20JVM-ch03/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM从入门到精通-第3讲-字节码文件结构"><a href="#JVM从入门到精通-第3讲-字节码文件结构" class="headerlink" title="JVM从入门到精通 第3讲: 字节码文件结构"></a>JVM从入门到精通 第3讲: 字节码文件结构</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第2讲：从源代码到机器码，发生了什么？</title>
      <link href="/01%20JVM-ch02/"/>
      <url>/01%20JVM-ch02/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM从入门到精通-第2讲-从源代码到机器码，发生了什么？"><a href="#JVM从入门到精通-第2讲-从源代码到机器码，发生了什么？" class="headerlink" title="JVM从入门到精通 第2讲: 从源代码到机器码，发生了什么？"></a>JVM从入门到精通 第2讲: 从源代码到机器码，发生了什么？</h2><h3 id="1、JVM的三个编译器"><a href="#1、JVM的三个编译器" class="headerlink" title="1、JVM的三个编译器"></a>1、JVM的三个编译器</h3><blockquote><p>&emsp;无论什么语言写的代码，其到最后都是通过机器码运行的。接下来就要从 <code>编译器</code> 角度，来看看Java源代码到机器码的中间过程发生了什么？</p><p>&emsp;JVM的编译器分为一下三部分：</p><ul><li><code>前端编译器:</code> Sun的javac、Eclipse JDT中的增量式编译器(ECJ)</li><li><code>JIT编译器:</code> HotSpot VM的C1、C2编译期</li><li><code>AOT编译器:</code> GNU Compiler for the Java (GCJ) .Excelsior JET</li></ul></blockquote><p><br></p><h3 id="2、前端编译器：源代码到字节码"><a href="#2、前端编译器：源代码到字节码" class="headerlink" title="2、前端编译器：源代码到字节码"></a>2、前端编译器：源代码到字节码</h3><blockquote><p>&emsp;对于 Java 虚拟机来说，其实际输入的是字节码文件，而不是 Java 文件。那么对于 Java 语言而言，其实怎么将 Java 代码转化成字节码文件的呢？我们知道在 JDK 的安装目录里有一个 javac 工具，就是它将 Java 代码翻译成字节码，这个工具我们叫做编译器。相对于后面要讲的其他编译器，其因为处于编译的前期，因此又被成为前端编译器。</p><p>&emsp;通过 javac 编译器，我们可以很方便地将 java 源文件翻译成字节码文件。</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.clz-blog.top//01%20jvm-img/jvm%2004.png"/></div></div><p><br></p><blockquote><p>&emsp;我们运行 javac 命令的过程，其实就是 javac 编译器解析 Java 源代码，并生成字节码文件的过程。说白了，其实就是使用 javac 编译器把 Java 语言规范转化为字节码语言规范。javac 编译器的处理过程可以分为下面四个阶段：</p><p>&emsp;第一个阶段：词法、语法分析。在这个阶段，javac 编译器会对源代码的字符进行一次扫描，最终生成一个抽象的语法树。简单地说，在这个阶段 javac 编译器会搞懂我们的代码到底想要干嘛。就像我们分析一个句子一样，我们会对句子划分主谓宾，弄清楚这个句子要表达的意思一样。</p><p>&emsp;第二个阶段：填充符号表。我们知道类之间是会互相引用的，但在编译阶段，我们无法确定其具体的地址，所以我们会使用一个符号来替代。在这个阶段做的就是类似的事情，即对抽象的类或接口进行符号填充。等到类加载阶段，javac 编译器会将符号替换成具体的内存地址。</p><p>&emsp;第三个阶段：注解处理。我们知道 Java 是支持注解的，因此在这个阶段会对注解进行分析，根据注解的作用将其还原成具体的指令集。</p><p>&emsp;第四个阶段：分析与字节码生成。到了这个阶段，javac 编译器便会根据上面几个阶段分析出来的结果，进行字节码的生成，最终输出为 class 文件。</p><p>我们一般称 javac 编译器为前端编译器，因为其发生在整个编译的前期。常见的前端编译器有 Sun 的 javac，Eclipse JDT 的增量式编译器（ECJ）。</p></blockquote><p><br></p><h3 id="3、JIT-编译器：从字节码到机器码"><a href="#3、JIT-编译器：从字节码到机器码" class="headerlink" title="3、JIT 编译器：从字节码到机器码"></a>3、JIT 编译器：从字节码到机器码</h3><blockquote><p>&emsp;当源代码转化为字节码之后，其实要运行程序，有两种选择。一种是使用 Java 解释器解释执行字节码，另一种则是使用 JIT 编译器将字节码转化为本地机器代码。</p><p>&emsp;这两种方式的区别在于，前者启动速度快但运行速度慢，而后者启动速度慢但运行速度快。至于为什么会这样，其原因很简单。因为解释器不需要像 JIT 编译器一样，将所有字节码都转化为机器码，自然就少去了优化的时间。而当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。所以在实际情况中，为了运行速度以及效率，我们通常采用两者相结合的方式进行 Java 代码的编译执行。</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.clz-blog.top//01%20jvm-img/jvm%2005.png"/></div></div><blockquote><p>&emsp;在 HotSpot 虚拟机内置了两个即时编译器，分别称为 Client Compiler 和Server Compiler。这两种不同的编译器衍生出两种不同的编译模式，我们分别称之为：C1 编译模式，C2 编译模式。</p><p>&emsp;注意：现在许多人习惯上将 Client Compiler 称为 C1 编译器，将 Server Compiler 称为 C2 编译器，但在 Oracle 官方文档中将其描述为 compiler mode（编译模式）。所以说 C1 编译器、C2 编译器只是我们自己的习惯性称呼，并不是官方的说法。这点需要特别注意。</p></blockquote><p>&emsp;<font color=red size=3><strong>那么 C1 编译模式和 C2 编译模式有什么区别呢？</strong></font></p><blockquote><p>&emsp;C1 编译模式会将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。而 C2 编译模式，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</p><p>&emsp;简单地说 C1 编译模式做的优化相对比较保守，其编译速度相比 C2 较快。而 C2 编译模式会做一些激进的优化，并且会根据性能监控做针对性优化，所以其编译质量相对较好，但是耗时更长。</p></blockquote><p>&emsp;<font color=red size=3><strong>那么到底应该选择 C1 编译模式还是 C2 编译模式呢？</strong></font></p><blockquote><p>实际上对于 HotSpot 虚拟机来说，其一共有三种运行模式可选，分别是：</p><ul><li>混合模式（Mixed Mode） 。即 C1 和 C2 两种模式混合起来使用，这是默认的运行模式。如果你想单独使用 C1 模式或 C2 模式，使用 <code>-client</code> 或 <code>-server</code> 打开即可。</li><li>解释模式（Interpreted Mode）。即所有代码都解释执行，使用 <code>-Xint</code> 参数可以打开这个模式。</li><li>编译模式（Compiled Mode）。 此模式优先采用编译，但是无法编译时也会解释执行，使用 <code>-Xcomp</code> 打开这种模式。</li></ul><p>&emsp;在命令行中输入 <code>java -version</code> 可以看到，我机器上的虚拟机使用 Mixed Mode 运行模式。</p><p>&emsp;写到这里，我们了解了从 Java 源代码到字节码，再从字节码到机器码的全过程。本来到这里就应该结束了，但在我们 Java 中还有一个 AOT 编译器，它能直接将源代码转化为机器码。</p></blockquote><p><br></p><h3 id="4、AOT-编译器：源代码到机器码"><a href="#4、AOT-编译器：源代码到机器码" class="headerlink" title="4、AOT 编译器：源代码到机器码"></a>4、AOT 编译器：源代码到机器码</h3><blockquote><p>&emsp;AOT 编译器的基本思想是：在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。</p><p>&emsp;但是 Java 语言本身的动态特性带来了额外的复杂性，影响了 Java 程序静态编译代码的质量。例如 Java 语言中的动态类加载，因为 AOT 是在程序运行前编译的，所以无法获知这一信息，所以会导致一些问题的产生。</p><p>&emsp;总的来说，AOT 编译器从编译质量上来看，肯定比不上 JIT 编译器。其存在的目的在于避免 JIT 编译器的运行时性能消耗或内存消耗，或者避免解释程序的早期性能开销。</p><p>&emsp;在运行速度上来说，AOT 编译器编译出来的代码比 JIT 编译出来的慢，但是比解释执行的快。而编译时间上，AOT 也是一个始终的速度。所以说，AOT 编译器的存在是 JVM 牺牲质量换取性能的一种策略。</p><p>&emsp;就如 JVM 其运行模式中选择 Mixed 混合模式一样，使用 C1 编译模式只进行简单的优化，而 C2 编译模式则进行较为激进的优化。充分利用两种模式的优点，从而达到最优的运行效率。</p></blockquote><p><br></p><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><blockquote><p>&emsp;在 JVM 中有三个非常重要的编译器，它们分别是：<code>前端编译器、JIT 编译器、AOT 编译器。</code></p><p>&emsp;<code>前端编译器</code>，最常见的就是我们的 javac 编译器，其将 Java 源代码编译为 Java 字节码文件。</p><p>&emsp;<code>JIT 即时编译器</code>，最常见的是 HotSpot 虚拟机中的 Client Compiler 和 Server Compiler，其将 Java 字节码编译为本地机器代码。</p><p>&emsp;而 <code>AOT 编译器</code> 则能将源代码直接编译为本地机器码。这三种编译器的编译速度和编译质量如下：</p><ul><li>编译速度上，解释执行 &gt; AOT 编译器 &gt; JIT 编译器。</li><li>编译质量上，JIT 编译器 &gt; AOT 编译器 &gt; 解释执行。</li></ul><p>&emsp;而在 JVM 中，通过这几种不同方式的配合，使得 JVM 的编译质量和运行速度达到最优的状态。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE面试(八股文)</title>
      <link href="/JavaSE%E9%9D%A2%E8%AF%95/"/>
      <url>/JavaSE%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaSE面试-八股文"><a href="#JavaSE面试-八股文" class="headerlink" title="JavaSE面试(八股文)"></a>JavaSE面试(八股文)</h1><h1 id="01-JavaSE面试"><a href="#01-JavaSE面试" class="headerlink" title="01 JavaSE面试"></a>01 JavaSE面试</h1><h2 id="chapter01-Java语言"><a href="#chapter01-Java语言" class="headerlink" title="chapter01 Java语言"></a>chapter01 Java语言</h2><h4 id="01-Java语言具有哪些特点？"><a href="#01-Java语言具有哪些特点？" class="headerlink" title="01 Java语言具有哪些特点？"></a>01 Java语言具有哪些特点？</h4><p>&nbsp;<br><br>&nbsp;<br></p><h2 id="chapter02"><a href="#chapter02" class="headerlink" title="chapter02"></a>chapter02</h2><p>&nbsp;<br><br>&nbsp;<br></p><h2 id="chapter21-异常"><a href="#chapter21-异常" class="headerlink" title="chapter21 异常"></a>chapter21 异常</h2><h4 id="01-简述Java异常的分类"><a href="#01-简述Java异常的分类" class="headerlink" title="01. 简述Java异常的分类"></a>01. 简述Java异常的分类</h4><blockquote><p>​    ==Java异常分为Error（程序无法处理的错误），Exception（程序本身可以处理的异常），这两个类均继承Throwable==</p><p>​    Error常见的有<code>StackOverFlowError、OutOfMemoryError</code>等；</p><p>​    Exception可分为 ==运行时异常== 和 ==非运行时异常== ；</p><p>​    对于运行时异常，可以利用 ==try~catch== 的方式进行处理，也可以不处理；</p><p>​    对于编译时异常，必须处理，不处理的话程序无法通过编译；</p></blockquote><!-- ![异常的继承结构图](01 JavaSE面试.assets/异常的继承结构图.png) --><p><img src="01 JavaSE面试.assets/异常的继承结构图.png" alt="异常的继承结构图" style="zoom:50%;" /></p><p><img src="01 JavaSE面试.assets/image-20220428104728285.png" alt="image-20220428104728285" style="zoom:50%;" /></p><p><img src="01 JavaSE面试.assets/image-20220428104750178.png" alt="image-20220428104750178" style="zoom:50%;" /></p><p>&nbsp;<br></p><h4 id="02-简述throw和throws的区别"><a href="#02-简述throw和throws的区别" class="headerlink" title="02. 简述throw和throws的区别"></a>02. 简述throw和throws的区别</h4><blockquote><p><strong>作用位置：</strong></p><p>​    throw在方法体内部，throws在方法签名处、声明处；</p><p><strong>作用对象：</strong></p><p>​    throw抛出具体异常对象，throws声明可能抛出异常的异常类型；</p><p><strong>作用效果：</strong></p><p>​    throw每次只能抛出一个异常对象（源头，制造异常），throws代表该方法可能会抛出的异常列表（提醒调用者）；</p></blockquote><p>&nbsp;<br></p><h4 id="03-简述final、finally、finalize的区别"><a href="#03-简述final、finally、finalize的区别" class="headerlink" title="03. 简述final、finally、finalize的区别"></a>03. 简述final、finally、finalize的区别</h4><blockquote><p>​    final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承</p><p>​    finally 用于抛异常，finally代码块内语句无论是否发生异常，都会在执行finally，常用于一些流的关闭。</p><p>​    finalize方法用于垃圾回收。</p><p>​    一般情况下不需要我们实现 finalize，当对象被回收的时候需要释放一些资源，比如socket链接，在对象初始化时创建，整个生命周期内有效，那么需要实现 finalize 方法，关闭这个链接。</p><p>​    但是当调用finalize方法后，并不意味着gc会立即回收该对象，所以有可能真正调用的时候，对象又不需要回收了，然后到了真正要回收的时候，因为之前调用过一次，这次又不会调用了，产生问题。所以，不推荐使用finalize方法。</p></blockquote><p>&nbsp;<br></p><h4 id="04-try-中-return-了，finally-还会执行吗？"><a href="#04-try-中-return-了，finally-还会执行吗？" class="headerlink" title="04. try 中 return 了，finally 还会执行吗？"></a>04. try 中 return 了，finally 还会执行吗？</h4><blockquote><p>​    会执行，并且finally的执行早于try里面return</p><p>结论：</p><ul><li>① 不管有木有出现异常，finally块中代码都会执行；</li><li>② 当 try 和 catch 中有 return 时，finally 仍然会执行；</li><li>③ finally 是在 return 后面的表达式运算后执行的 (此时并没有返回运算后的值，而是先把要返回的值保存起来，管</li></ul><p>finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值)，所以函数返回值是在 finally 执行前确定的；</p><ul><li>④ finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值；</li></ul></blockquote><p>&nbsp;<br></p><h4 id="05-finally代码块是否一定会执行？"><a href="#05-finally代码块是否一定会执行？" class="headerlink" title="05. finally代码块是否一定会执行？"></a>05. finally代码块是否一定会执行？</h4><blockquote><p>当遇到下面情况不会执行。</p><ul><li><p>① 当程序在进入try语句块之前就出现异常时会直接结束。</p></li><li><p>② 当程序在try块中强制退出时，如使用 <code>System.exit(0)</code>，也不会执行finally块中的代码。</p></li></ul><p>​    其它情况下，在<code>try/catch/finally</code>语句执行的时候，try块先执行，</p><ul><li>当有异常发生，catch和finally进行处理后程序就结束了，</li><li><p>当没有异常发生，在执行完finally中的代码后，后面代码会继续执行。</p><p> 值得注意的是，当try/catch语句块中有return时，finally语句块中的代码会在return之前执行。</p></li></ul><p>​    如果try/catch/finally块中都有return语句，finally块中的return语句会覆盖try/catch模块中的return语句。</p></blockquote><p>&nbsp;<br></p><h4 id="06-简述常见的异常类"><a href="#06-简述常见的异常类" class="headerlink" title="06. 简述常见的异常类"></a>06. 简述常见的异常类</h4><blockquote><p>1.NullPointerException：空指针异常；</p><p>2.SQLException：数据库相关的异常；</p><p>3.IndexOutOfBoundsException：数组下角标越界异常；</p><p>4.FileNotFoundException：打开文件失败时抛出；</p><p>5.IOException：当发生某种IO异常时抛出；</p><p>6.ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出此异常；</p><p>7.NoSuchMethodException：无法找到某一方法时，抛出；</p><p>8.ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常；</p><p>9.NumberFormatException：当试图将字符串转换成数字时，失败了，抛出；</p><p>10.IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。</p><p>11.ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</p></blockquote><p>&nbsp;<br></p><h4 id="07-自定义异常在生产中如何应用"><a href="#07-自定义异常在生产中如何应用" class="headerlink" title="07. 自定义异常在生产中如何应用"></a>07. 自定义异常在生产中如何应用</h4><blockquote><p>​    Java虽然提供了丰富的异常处理类，但是在项目中还会经常使用自定义异常，其主要原因是Java提供的异常类在某些情况下还</p><p>是不能满足实际需球。</p><p>例如以下情况：</p><ul><li><p>① 系统中有些错误是符合Java语法，但不符合业务逻辑。</p></li><li><p>② 在分层的软件结构中，通常是在表现层统一对系统其他层次的异常进行捕获处理。</p></li></ul></blockquote><p>&nbsp;<br><br>&nbsp;<br></p><h2 id="chapter22-集合与泛型"><a href="#chapter22-集合与泛型" class="headerlink" title="chapter22 集合与泛型"></a>chapter22 集合与泛型</h2><h4 id="01-简述泛型"><a href="#01-简述泛型" class="headerlink" title="01. 简述泛型"></a>01. 简述泛型</h4><blockquote><p>​    泛型，即 “参数化类型”，解决不确定对象具体类型的问题，在编译阶段有效。</p><p>​    在泛型使用过程中，操作的数据类型被指定为一个参数，这个参数类型在类中称为泛型类、接口中称为泛型接口、方法中称为泛</p><p>型方法。</p></blockquote><p>泛型是Java SE1.5之后的特性，《Java 核心技术》中对泛型的定义是：</p><blockquote><p>“泛型”意味着编写的代码==可以被不同类型的对象所重用==</p></blockquote><p>“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的</p><p>ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如<code>Iteger、String</code>，自定义的各种类型等。但在我们使用的使用通</p><p>过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; iniData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>使用泛型的好处</strong></p><blockquote><p>​    以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了</p><p>Object即可，添加的数据全部都可向上转型为Object。更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。</p></blockquote><p>&nbsp;<br></p><h4 id="02-简述泛型擦除"><a href="#02-简述泛型擦除" class="headerlink" title="02. 简述泛型擦除"></a>02. 简述泛型擦除</h4><blockquote><p>​    Java编译器生成的字节码是不包含泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为泛型擦除。</p></blockquote><p>&nbsp;<br></p><h4 id="03-简述Java容器种类"><a href="#03-简述Java容器种类" class="headerlink" title="03. 简述Java容器种类"></a>03. 简述Java容器种类</h4><p><strong>Collection继承结构图</strong></p><p><img src="01 JavaSE面试.assets/Collection结构图.png" alt="Collection结构图" style="zoom:50%;" /></p><p><strong>Map结构图</strong></p><p><img src="01 JavaSE面试.assets/Map结构图.png" alt="Map结构图" style="zoom:50%;" /></p><p>&nbsp;<br></p><h4 id="04-简述Collection和Collections的区别"><a href="#04-简述Collection和Collections的区别" class="headerlink" title="04. 简述Collection和Collections的区别"></a>04. 简述Collection和Collections的区别</h4><blockquote><p>1.Collection是最基本的集合接口，Collection派生了两个子接口list和set，分别定义了两种不同的存储方式；</p><p>2.Colleections是包装类（集合工具类），它包含各种有关集合操作的静态方法（对集合的搜索、排序、线程安全化等）；</p><p>此类不能实例化，就像一个工具类，服务于Collection框架。</p></blockquote><p>&nbsp;<br></p><h4 id="05-简述Java的List"><a href="#05-简述Java的List" class="headerlink" title="05. 简述Java的List"></a>05. 简述Java的List</h4><blockquote><p>​    List是一个有序队列，在JAVA中有两种实现方式：</p><ul><li>① ==ArrayList== 使用数组实现，是容量可变的非线程安全列表，随机访问快，集合扩容时会创建更大的数组，把原有数组复制到新数组。</li><li>② ==LinkedList== 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。</li></ul></blockquote><p>&nbsp;<br></p><h4 id="06-简述ArrayList、LinkedList和Vector的共同点与区别"><a href="#06-简述ArrayList、LinkedList和Vector的共同点与区别" class="headerlink" title="06. 简述ArrayList、LinkedList和Vector的共同点与区别"></a>06. 简述ArrayList、LinkedList和Vector的共同点与区别</h4><blockquote><p>​    ① ArrayList、Vector 和 LinkedList 都是可以 ==动态改变长度的数组。==</p><p>​    ② ArrayList和Vector都是基于存储元素的 Object[] array来实现的，</p><p>​    它们会在内存中开辟一块连续的空间来存储，支持下标、索引访问。</p><p>​    但在涉及插入元素时可能需要移动容器中的元素，插入效率较低。</p><p>​    当存储元素超过容器的初始化容量大小，ArrayList与Vector均会进行扩容。</p><p>​    ③ LinkedList采用双向列表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，</p><p>​    但在插入元素的时候不需要对数据进行移动，插入效率较高。</p><p>​    ④  Vector是线程安全的，其大部分方法是直接或间接同步的。</p><p>​    ArrayList不是线程安全的，其方法不具有同步性质。LinkedList也不是线程安全的。</p></blockquote><p><img src="01 JavaSE面试.assets/image-20220428111054604.png" alt="image-20220428111054604" style="zoom:50%;" /></p><p>&nbsp;<br></p><h4 id="07-简述Java的Set"><a href="#07-简述Java的Set" class="headerlink" title="07. 简述Java的Set"></a>07. 简述Java的Set</h4><blockquote><p>​    Set 即集合，该数据结构不允许元素重复且无序。JAVA对Set有三种实现方式：</p><p>​    ① ==HashSet== 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，Value系统自定义一个名为 PRESENT 的 Object 类型常量。判断元素是否相同时，先比较hashCode，相同后再利用equals比较，查询 O(1)</p><p>​    ② ==LinkedHashSet== 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。</p><p>​    ③ ==TreeSet== 通过 TreeMap 实现的，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。查询 O(logn)</p></blockquote><p>&nbsp;<br></p><h4 id="08-简述HashSet中equals与hashCode的关系"><a href="#08-简述HashSet中equals与hashCode的关系" class="headerlink" title="08. 简述HashSet中equals与hashCode的关系"></a>08. 简述HashSet中equals与hashCode的关系</h4><blockquote><p>​    equals和hashCode这两个方法都是从object类中继承过来的，equals主要用于判断对象的内存地址引用是否是同一个地址；</p><p>​    hashCode根据定义的哈希规则将对象的内存地址转换为一个哈希码。</p><p>​    HashSet中存储的元素是不能重复的，主要通过hashCode与equals两个方法来判断存储的对象是否相同：</p><ol><li>如果两个对象的hashCode值不同，说明两个对象不相同。</li><li>如果两个对象的hashCode值相同，接着会调用对象的equals方法，如果equlas方法的返回结果为true，那么说明两个对象相同，否则不相同。</li></ol></blockquote><p>&nbsp;<br></p><h4 id="09-简述java的TreeMap"><a href="#09-简述java的TreeMap" class="headerlink" title="09. 简述java的TreeMap"></a>09. 简述java的TreeMap</h4><blockquote><p>​    ==TreeMap== 是底层利用红黑树实现的Map结构，底层实现是一棵平衡的排序二叉树，由于红黑树的插入、删除、遍历时间复杂度都为O(logN)，所以性能上低于哈希表。</p><p>​    但是哈希表无法提供键值对的有序输出，红黑树可以按照键的值的大小有序输出。</p></blockquote><p>&nbsp;<br></p><h4 id="10-简述JAVA的HashMap，JDK1-7与1-8的区别"><a href="#10-简述JAVA的HashMap，JDK1-7与1-8的区别" class="headerlink" title="10. 简述JAVA的HashMap，JDK1.7与1.8的区别"></a>10. 简述JAVA的HashMap，JDK1.7与1.8的区别</h4><blockquote><p>​    JDK8 之前底层实现是数组 + 链表，JDK8 改为数组 + 链表/红黑树。主要成员变量包括存储数据的table 数组、元素数量 size、</p><p>加载因子 loadFactor。</p><p>​    HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的hash 值一样，就会发生哈希</p><p>冲突，被放到同一个链表上。</p><p>​    table 数组记录 HashMap 的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链表，Node/Entry 节点包</p><p>含四个成员变量：key、value、next 指针和 hash 值。在JDK8后链表超过8会转化为红黑树。</p><p>​    若当前数据/总数据容量&gt;负载因子，Hashmap将执行扩容操作。</p><p>​    默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1&lt;&lt; 30 、默认加载因子为 0.75。</p></blockquote><p>&nbsp;<br></p><h4 id="11-简述HashMap和HashTable的区别"><a href="#11-简述HashMap和HashTable的区别" class="headerlink" title="11. 简述HashMap和HashTable的区别"></a>11. 简述HashMap和HashTable的区别</h4><blockquote><p>1.HashMap是线程不安全的，HashTable是线程安全的；在多线程访问HashMap需要提供额外的同步机制。</p><p>2.HashMap是Hashtable的轻量级实现，HashMap中运行键和值为null（最多一个key为null），HashTable不允许；</p><p>3.HashTable的默认容量是16，以2的倍数扩容；HashTable是11，以2*n+1扩容；（扩容因子：0.75）</p><p>4.Hashtable使用Enumeration进行遍历，HashMap使用Iterator进行遍历。</p></blockquote><p><img src="01 JavaSE面试.assets/image-20220428111121161.png" alt="image-20220428111121161" style="zoom:50%;" /></p><p>&nbsp;<br></p><h4 id="12-简述何时使用HashMap、TreeMap"><a href="#12-简述何时使用HashMap、TreeMap" class="headerlink" title="12. 简述何时使用HashMap、TreeMap"></a>12. 简述何时使用HashMap、TreeMap</h4><blockquote><p>​    如果对Map进行插入、删除或定位一个元素的操作更频繁，HashMap是更好的选择。</p><p>​    如果需要对key集合进行有序的遍历，TreeMap是更好的选择。</p></blockquote><p>&nbsp;<br></p><h4 id="13-简述下List、Set、Map三种的区别"><a href="#13-简述下List、Set、Map三种的区别" class="headerlink" title="13. 简述下List、Set、Map三种的区别"></a>13. 简述下List、Set、Map三种的区别</h4><blockquote><p>​    <strong>List(对付顺序的好帮手)</strong>：List接口存储一组不唯一(可以有多个元素引用相同的对象)，有序的对象</p><p>​    <strong>Set(注重独—无二的性质)</strong>：不允许重复的集合。不会有多个元素引用相同的对象。</p><p>​    <strong>Map(用Key来搜索的专家)</strong>：使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重</p><p>复，典型的Key是String类型，但也可以是任何对象。</p></blockquote><p>&nbsp;<br></p><h4 id="15-简述Java中线程安全的数据结构"><a href="#15-简述Java中线程安全的数据结构" class="headerlink" title="15. 简述Java中线程安全的数据结构"></a>15. 简述Java中线程安全的数据结构</h4><blockquote><p>​    HashTable： 哈希表的线程安全版，效率低</p><p>​    ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代HashTable</p><p>​    Vector：线程安全版Arraylist</p><p>​    Stack：线程安全版栈</p><p>​    BlockingQueue及其子类：线程安全版队列</p></blockquote><p>&nbsp;<br></p><h4 id="16-为何HashMap线程不安全？"><a href="#16-为何HashMap线程不安全？" class="headerlink" title="16. 为何HashMap线程不安全？"></a>16. 为何HashMap线程不安全？</h4><blockquote><p>​    在JDK1.7中，HashMap采用头插法插入元素，因此并发情况下会导致环形链表，产生死循环。</p><p>​    虽然JDK1.8采用了尾插法解决了这个问题，但是并发下的put操作也会使前一个key被后一个key覆盖。由于HashMap有扩容机制</p><p>存在，也存在A线程进行扩容后，B线程执行get方法出现失误的情况。</p></blockquote><p>&nbsp;<br></p><h4 id="17-为何集合类没有实现Cloneable和Serializable接口？"><a href="#17-为何集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="17. 为何集合类没有实现Cloneable和Serializable接口？"></a>17. 为何集合类没有实现Cloneable和Serializable接口？</h4><blockquote><p>​    克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。</p><p>​    因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p></blockquote><p>&nbsp;<br></p><h4 id="21-简述JAVA的迭代器-Iterator"><a href="#21-简述JAVA的迭代器-Iterator" class="headerlink" title="21. 简述JAVA的迭代器(Iterator)"></a>21. 简述JAVA的迭代器(Iterator)</h4><blockquote><p>​    Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。</p><p>​    迭代器可以在迭代的过程中删除底层集合的元素，但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。</p></blockquote><p>&nbsp;<br></p><h4 id="22-简述fail-fast和fail-safe迭代器的区别"><a href="#22-简述fail-fast和fail-safe迭代器的区别" class="headerlink" title="22. 简述fail-fast和fail-safe迭代器的区别"></a>22. 简述fail-fast和fail-safe迭代器的区别</h4><blockquote><p>​    ① ==fail-fast== 直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，</p><p>​    就会立刻抛出ConcurrentModificationException异常从而导致遍历失败。</p><p>​    常见的使用fail-fast方式的容器有 <code>HashMap</code> 和 <code>ArrayList</code> 等。</p><p>​    ② ==fail-safe== 这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。</p><p>​    常见的使用fail-safe方式遍历的容器有 <code>ConcurrentHashMap</code> 和 <code>CopyOnWriteArrayList</code>。</p></blockquote><p><img src="01 JavaSE面试.assets/image-20220428112519832.png" alt="image-20220428112519832" style="zoom:50%;" /></p><h4 id="25-简述Java优先级队列-Priority-Queue"><a href="#25-简述Java优先级队列-Priority-Queue" class="headerlink" title="25. 简述Java优先级队列(Priority Queue)"></a>25. 简述Java优先级队列(Priority Queue)</h4><blockquote><p>​    PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。</p><p>​    在创建的时候，我们可以给它提供一个负责给元素排序的比较器。</p><p>​    PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。</p><p>​    最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。</p></blockquote><p>&nbsp;<br></p><h2 id="chapter23-IO"><a href="#chapter23-IO" class="headerlink" title="chapter23 IO"></a>chapter23 IO</h2><h4 id="01-简述Java中的IO流"><a href="#01-简述Java中的IO流" class="headerlink" title="01. 简述Java中的IO流"></a>01. 简述Java中的IO流</h4><blockquote><p>1、按流划分：输入流和输出流；</p><p>2、按操作单位划分：字节流和字符流；</p><p>​    字节流：inputStream、outStream；</p><p>​    字符流：reader、writer；</p><p>3、按流的角色划分：节点流和处理流</p><p>​    Java l0流的40多个类都是从如下4个抽象类基类中派生出来的：</p><ul><li><code>InputStream/Reader</code>：所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>outputStream/writer</code>：所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul></blockquote><p><img src="01 JavaSE面试.assets/image-20220428105326455.png" alt="image-20220428105326455" style="zoom:50%;" /></p><p>&nbsp;<br></p><h4 id="11-简述序列化"><a href="#11-简述序列化" class="headerlink" title="11. 简述序列化"></a>11. 简述序列化</h4><blockquote><p>​    序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。</p><p>​    序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该流读取出来重新构造</p><p>成一个相同的对象。</p><p>​    序列化是通过实现Serializable接口，该接口没有需要实现的方法，implement Serialiable只是为了标注该对象是可被序列化的，</p><p>使用一个输出流（FileOutStream）来构造一个ObjectOutputStream对象，接着使用ObjectOutputStream对象的writeObject方法</p><p>就可以将参数的obj对象输出到磁盘，需要恢复的实话使用输入流。</p><p>​    ==序列化是将对象转换为容易传输的格式的过程，最主要的目的就是传递和保存对象，保存对象的完整性和可传递性==</p></blockquote><h4 id="12-简述Java序列化与反序列化的实现"><a href="#12-简述Java序列化与反序列化的实现" class="headerlink" title="12. 简述Java序列化与反序列化的实现"></a>12. 简述Java序列化与反序列化的实现</h4><blockquote><p>​    序列化：将java对象转化为字节序列，由此可以通过网络对象进行传输。</p><p>​    反序列化：将字节序列转化为java对象。</p><p>​    具体实现：实现 ==Serializable接口，==或实现 ==Externalizable接口== 中的 <code>writeExternal()</code> 与 <code>readExternal()</code> 方法。</p></blockquote><p>&nbsp;<br><br>&nbsp;<br></p><h2 id="chapter24-线程基础"><a href="#chapter24-线程基础" class="headerlink" title="chapter24 线程基础"></a>chapter24 线程基础</h2><h4 id="01-简述线程、程序、进程的基本概念以及之间关系"><a href="#01-简述线程、程序、进程的基本概念以及之间关系" class="headerlink" title="01. 简述线程、程序、进程的基本概念以及之间关系"></a>01. 简述线程、程序、进程的基本概念以及之间关系</h4><blockquote><p>​    线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。</p><p>​    与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>​    程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p>​    进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</p><p>​    系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>​    简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如：CPU时间、内存空间、文件、输入输出设备的使用权等等。、</p><p>​    换句话说，当程序在执行时，将会被操作系统载入内存中。线程是进程划分成的更小的运行单位。</p><p>​    线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</p><p>​    从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p></blockquote><p>&nbsp;<br></p><h4 id="02-简述进程和线程的区别"><a href="#02-简述进程和线程的区别" class="headerlink" title="02. 简述进程和线程的区别"></a>02. 简述进程和线程的区别</h4><blockquote><p>​    进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p><p><strong>线程与进程的区别归纳：</strong></p><ul><li>① ==地址空间和其它资源：==进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li><li>② ==通信：==进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信，需要进程同步和互斥手段的辅助，以保证数据的一致性。</li><li>③ ==调度和切换：==线程上下文切换比进程上下文切换要快得多。</li><li>④ 在多线程OS中，进程不是一个可执行的实体。</li></ul></blockquote><p>&nbsp;<br></p><h4 id="03-简述线程的基本状态"><a href="#03-简述线程的基本状态" class="headerlink" title="03. 简述线程的基本状态"></a>03. 简述线程的基本状态</h4><blockquote><p>​    ==新建(new)：==新创建了一个线程对象。</p><p>​    ==可运行(runnable)：==线程对象创建后，其他线程 (比如main线程) 调用了该对象的 <code>start()</code> 方法。</p><p>​    该状态的线程位于可运行线程中，等待被线程调度选中，获取cpu的使用权。</p><p>​    ==运行(running)：==可运行状态(runnable)的线程获得了cpu时间片 (timeslice)，执行程序代码。</p><p>​    ==阻塞(block)∶==阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。</p><p>​    直到线程进入可运行( runnable)状态，才有机会再次获得cpu timeslice转到运行(running )状态。</p><p>​    阻塞的情况分三种：</p><p>​    ① 等待阻塞：运行( running )的线程执行 <code>o.wait()</code>方法，JVM会把该线程放入等待队列(waitting queue)中。</p><p>​    ② 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lockpool)中。<br>​    ③ 其他阻塞：运行(running)的线程执行<code>Thread.sleep(long ms)</code>或<code>t.join()</code>方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者/O处理完毕时，线程重新转入可运行(runnable)状态。</p><p>​    ==死亡(dead)：==线程run()、main()方法执行结束,或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></blockquote><p><img src="01 JavaSE面试.assets/image-20220428105135519.png" alt="image-20220428105135519" style="zoom:50%;" /></p><p>&nbsp;<br><br>&nbsp;<br></p><h2 id="chapter25-反射"><a href="#chapter25-反射" class="headerlink" title="chapter25 反射"></a>chapter25 反射</h2><h4 id="01-简述Java反射机制"><a href="#01-简述Java反射机制" class="headerlink" title="01. 简述Java反射机制"></a>01. 简述Java反射机制</h4><blockquote><p>​    反射机制使得Java具有 ==动态获取程序信息和动态调用对象方法== 的能力。可以通过以下类调用反射API：</p><ul><li><p>Class类：获得类属性方法</p></li><li><p>Field类：获得类的成员变量</p></li><li><p>Method类：获取类的方法信息</p></li><li><p>Construct类：获取类的构造方法等信息</p></li></ul><p>​    在程序的运行过程中</p><ul><li>构造任意一个类的对象、</li><li>获取任意一个类的成员变量和成员方法、</li><li>获取任意一个对象所属的类信息、</li><li>调用任意一个对象的属性和方法。</li></ul></blockquote><p>&nbsp;</p><h4 id="02-简述Class对象"><a href="#02-简述Class对象" class="headerlink" title="02. 简述Class对象"></a>02. 简述Class对象</h4><blockquote><p>​    Java中对象可以分为 ==实例对象== 和 ==Class对象，==每一个类都有一个Class对象，其包含了与该类有关的信息。</p><p>​    获取Class对象的方法：</p><ul><li>类名.class</li><li>实例对象.getClass()</li><li>Class.forName(“类的全限定名”)</li><li>基本类型的包装类，可以调用包装类的Type属性来获得包装类的Class对象</li></ul></blockquote><p>&nbsp;</p><h4 id="03-简述Java实例化对象的方式"><a href="#03-简述Java实例化对象的方式" class="headerlink" title="03. 简述Java实例化对象的方式"></a>03. 简述Java实例化对象的方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 new</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 clone()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 反射机制</span></span><br><span class="line"><span class="comment">// 用 Class.forName方法获取类，在调用类的newinstance()方法</span></span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;com.dao.User&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) cls.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 序列化、反序列化</span></span><br><span class="line"><span class="comment">// 将一个对象实例化后，进行序列化，再反序列化，也可以获得一个对象(远程通信的场景下使用)</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span> (<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化对象</span></span><br><span class="line">out.writeObject(user1); </span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化对象</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/data.txt&quot;</span>));</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) in.readObject();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;反序列化user：&quot;</span> + user2);</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="04-简述Java反射机制优缺点"><a href="#04-简述Java反射机制优缺点" class="headerlink" title="04. 简述Java反射机制优缺点"></a>04. 简述Java反射机制优缺点</h4><blockquote><p>优点：</p><ul><li>能够运行时动态获取类的实例，提高灵活性；</li><li>与动态编译结合；</li></ul><p>缺点：</p><ul><li>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。解决方案：<ul><li>① 通过 <code>setAccessible(true)</code> 关闭JDK的安全检查来提升反射速度；</li><li>② 多次创建一个类的实例时，有缓存会快很多；</li><li>③ <code>ReflectASM</code>工具类，通过字节码生成的方式加快反射速度；</li></ul></li><li>相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性)</li></ul></blockquote><p>&nbsp;&nbsp;</p><h2 id="chapter26-注解"><a href="#chapter26-注解" class="headerlink" title="chapter26 注解"></a>chapter26 注解</h2><h4 id="01-简述注解"><a href="#01-简述注解" class="headerlink" title="01. 简述注解"></a>01. 简述注解</h4><blockquote><p>​    Java 注解用于为 Java 代码提供 ==元数据== ；</p><p>​    作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的；</p><p>​    其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作；</p></blockquote><p>&nbsp;</p><h4 id="02、简述元注解"><a href="#02、简述元注解" class="headerlink" title="02、简述元注解"></a>02、简述元注解</h4><blockquote><p>​    元注解可以理解为 ==注解的注解，==即在注解中使用，实现想要的功能。其具体分为：</p><ul><li><p><code>@Retention</code>：表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运行期（JVM中运行）</p></li><li><p><code>@Target</code>：表示注解作用的范围；</p></li><li><p><code>@Documented</code>：将注解中的元素包含到 Javadoc 中去；</p></li><li><p><code>@Inherited</code>：一个被@Inherited注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解；</p></li><li><p><code>@Repeatable</code>：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义；</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 05 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2</title>
      <link href="/03%20SpringBoot2/"/>
      <url>/03%20SpringBoot2/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 03 微服务框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三篇文章</title>
      <link href="/2023-01-01-%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023-01-01-%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第三篇文章"><a href="#第三篇文章" class="headerlink" title="第三篇文章"></a>第三篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇文章</title>
      <link href="/2023-01-01-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023-01-01-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第二篇文章"><a href="#第二篇文章" class="headerlink" title="第二篇文章"></a>第二篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql</title>
      <link href="/04%20MySql/"/>
      <url>/04%20MySql/</url>
      
        <content type="html"><![CDATA[<h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 04 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM</title>
      <link href="/02%20SSM/"/>
      <url>/02%20SSM/</url>
      
        <content type="html"><![CDATA[<h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 02 SSM框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 第1讲：到底什么是JVM ?</title>
      <link href="/01%20JVM-ch01/"/>
      <url>/01%20JVM-ch01/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM从入门到精通-第1讲-到底什么是JVM"><a href="#JVM从入门到精通-第1讲-到底什么是JVM" class="headerlink" title="JVM从入门到精通 第1讲: 到底什么是JVM ?"></a>JVM从入门到精通 第1讲: 到底什么是JVM ?</h2><h3 id="1、软件包的系统适配"><a href="#1、软件包的系统适配" class="headerlink" title="1、软件包的系统适配"></a>1、软件包的系统适配</h3><blockquote><p>​    Windows 系统上一个软件包装包是 exe 后缀的，而这个软件包在苹果的 Mac OSX 系统上是无法安装的。</p><p>​    类似地，Mac OSX 系统上软件安装包则是 dmg 后缀，同样无法在 Windows 系统上安装。</p><p>​    为什么不同系统上的软件无法安装，这是因为操作系统底层的实现是不一样的。</p><ul><li><p>对于 Windows 系统来说，exe 后缀的软件代码最终编译成 Windows 系统能识别的机器码。</p></li><li><p>而 Mac OSX 系统来说，dmg 后缀的软件代码最终编译成 Mac OSX 系统能识别的代码。</p></li></ul></blockquote><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.clz-blog.top//01%20jvm-img/jvm%2001.png"/></div></div><p><br></p><h3 id="2、Jva程序的系统适配"><a href="#2、Jva程序的系统适配" class="headerlink" title="2、Jva程序的系统适配"></a>2、Jva程序的系统适配</h3><blockquote><p>​    系统软件无法通用是一个常见的问题。但使用过 Java 的同学都知道，Java 代码可以在服务端（Linux 系统）运行，也可以在 Windows 系统运行，但我们并没有生成多份不同的代码。所以 Java 语言是如何做到的呢？</p><p>​    与其他语言不同，Java 语言并不直接将代码编译成与系统有关的机器码，而是编译成一种特定的语言规范，这种语言规范我们称之为字节码。无论 Java 程序要在 Windows 系统，还是 Mac OSX 系统，抑或是 Linux 系统，它首先都得编译成字节码文件，之后才能运行。</p><p>​    但即使编译成字节码文件了，各个系统还是无法明白字节码文件的内容，这时候就需要 Java 虚拟机的帮助了。Java 虚拟机会解析字节码文件的内容，并将其翻译为各操作系统能理解的机器码。</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.clz-blog.top//01%20jvm-img/jvm%2002.png"/></div></div><p><br></p><h3 id="3、到底什么是虚拟机？"><a href="#3、到底什么是虚拟机？" class="headerlink" title="3、到底什么是虚拟机？"></a>3、到底什么是虚拟机？</h3><blockquote><p>&emsp;简单地说，对于同样一份 Java 源码文件，我们编译成字节码之后，无论是 Linux 系统还是 Windows 系统都不认识。这时候 Java 虚拟机就是一个翻译官，在 Linux 系统上翻译成 Linux 机器码给 Linux 系统听，在 Windows 系统上翻译成 Windows 机器码给 Windows 系统听。这样一来，Java 就实现了「Write Once，Run Anywhere」的伟大愿景了。</p><p>&emsp;在 Java 虚拟机还没出现之前，为了支持软件在不同系统上运行，我们必须在多个平台写多份代码，分别对应特定的系统。但 Java 虚拟机出现之后，你只需要按照特定规范编译书写，编译器编译成字节码文件后，虚拟机会帮你将字节码生成对应的 Windows Code 和 Mac Code。本质上最终还是会生成 Windows Code 和 Mac Code 两份机器代码，但对于开发人员来说，却只需要写一次代码了。Java 虚拟机帮开发人员承担了重复的工作，让开发效率更高了。</p><p>&emsp;很多初学者关于 Java 虚拟机有一个误区，他们会觉得 Java 虚拟机只能运行 Java 代码。但实际上 Java 虚拟机运行的是字节码文件。换句话说，如果你用 php 语言写一段代码，并自己用特定编译器能生成符合字节码规范的字节码文件，那么 Java 虚拟机也是可以运行的。</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.clz-blog.top//01%20jvm-img/jvm%2002.png"/></div></div><p><br></p><blockquote><p>&emsp;所以虽然名字是 Java 虚拟机，但 Java 虚拟机与 Java 语言没有直接关系，它只按照 Java 虚拟机规范去读取 Class 文件，并按照规定去解析、执行字节码指令，仅此而已。</p><p>&emsp;如果你够牛逼，你完全可以写一个编译器，将 PHP 语言代码编译成符合 Java 虚拟机规范的字节码文件，那么 Java 虚拟机也是可以执行的。</p><p>&emsp;准确地说，Java 虚拟机与字节码文件（Class文件）绑定。</p><p>&emsp;最后，让我们回顾一下，到底什么是虚拟机？其实 Java 虚拟机就是一个 <code>字节码翻译器</code>，<strong>它将字节码文件翻译成各个系统对应的机器码，确保字节码文件能在各个系统正确运行。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE</title>
      <link href="/01%20JavaSE/"/>
      <url>/01%20JavaSE/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023-01-01-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023-01-01-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01 Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/readPercent.css"/>
      <url>/css/readPercent.css</url>
      
        <content type="html"><![CDATA[/* 返回顶部 */button#go-up #percent {    display: none;    font-weight: bold;    font-size: 15px !important;}button#go-up span {    font-size: 12px !important;    margin-right: -1px;}/* 鼠标滑动到按钮上时显示返回顶部图标 */button#go-up:hover i {    display: block !important;}button#go-up:hover #percent {    display: none !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[:root {    --trans-light: rgba(255, 255, 255, 0.80);    --trans-dark: rgba(25, 25, 25, 0.80);    --border-style: 1px solid rgb(169, 169, 169);    --backdrop-filter: blur(8px) saturate(150%);}/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {    -webkit-animation: ccc 4s linear infinite;    animation: ccc 4s linear infinite;}/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@-webkit-keyframes ccc {    0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg);    }    to {        -webkit-transform: rotate(-1turn);        transform: rotate(-1turn);    }}@keyframes ccc {    0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg);    }    to {        -webkit-transform: rotate(-1turn);        transform: rotate(-1turn);    }}/* 设置风车颜色 */#content-inner.layout h1::before {    color: #ef50a8;    margin-left: -1.55rem;    font-size: 1.3rem;    margin-top: -0.23rem;}#content-inner.layout h2::before {    color: #fb7061;    margin-left: -1.35rem;    font-size: 1.1rem;    margin-top: -0.12rem;}#content-inner.layout h3::before {    color: #ffbf00;    margin-left: -1.22rem;    font-size: 0.95rem;    margin-top: -0.09rem;}#content-inner.layout h4::before {    color: #a9e000;    margin-left: -1.05rem;    font-size: 0.8rem;    margin-top: -0.09rem;}#content-inner.layout h5::before {    color: #57c850;    margin-left: -0.9rem;    font-size: 0.7rem;    margin-top: 0rem;}#content-inner.layout h6::before {    color: #5ec1e0;    margin-left: -0.9rem;    font-size: 0.66rem;    margin-top: 0rem;}/* s设置风车hover动效 6s那里可以自己调节快慢*/#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {    color: var(--theme-color);}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {    color: var(--theme-color);    -webkit-animation: ccc 6s linear infinite;    animation: ccc 6s linear infinite;}/* 页脚与头图透明 */#footer {    background: transparent !important;}#page-header {    background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {    background: transparent !important;}#page-header::before {    background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}/* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {    background: #1e1e1e;    color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {    background: #3ecdf1;    color: #f2f2f2;}/* 一级菜单居中 */#nav .menus_items {    position: absolute !important;    width: fit-content !important;    left: 50% !important;    transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {    display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {    left: -38px;}/* 夜间模式菜单栏发光字 */[data-theme="dark"] #nav .site-page,[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li a {    text-shadow: 0 0 2px var(--theme-color) !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {    text-shadow: 0 0 2px var(--theme-color) !important;}/* 闪烁变动颜色连续渐变 */#site-name,#site-title,#site-subtitle,#post-info,.author-info__name,.author-info__description {    transition: text-shadow 1s linear !important;}/* 翻页按钮居中 */#pagination {    width: 100%;    margin: auto;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content>.card-widget.card-info {    background: linear-gradient(-45deg,            #e8d8b9,            #eccec5,            #a3e9eb,            #bdbdf0,            #eec1ea);    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@-moz-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content>.card-widget.card-info {    background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content>.card-widget.card-info>#card-info-btn {    background-color: #3eb8be;    border-radius: 8px;}/* 鼠标样式 */#cursor {    position: fixed;    width: 16px;    height: 16px;    /* 这里改变跟随的底色 */    background: rgb(57, 197, 187);    border-radius: 8px;    opacity: 0.25;    z-index: 10086;    pointer-events: none;    transition: 0.2s ease-in-out;    transition-property: background, opacity, transform;}#cursor.hidden {    opacity: 0;}#cursor.hover {    opacity: 0.1;    transform: scale(2.5);    -webkit-transform: scale(2.5);    -moz-transform: scale(2.5);    -ms-transform: scale(2.5);    -o-transform: scale(2.5);}#cursor.active {    opacity: 0.5;    transform: scale(0.5);    -webkit-transform: scale(0.5);    -moz-transform: scale(0.5);    -ms-transform: scale(0.5);    -o-transform: scale(0.5);}/* 首页文章卡片 */#recent-posts>.recent-post-item {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 25px;    border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 18px;    border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border: var(--border-style);    border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {    background: rgba(255, 255, 255, 0.75);    backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {    background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts>.recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {    background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {    background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {    background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;}[data-theme="dark"] .read-mode div#post {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;}/* 帧率检测 */#fps {    position: fixed;    /* 指定位置 */    left: 10px;    bottom: 10px;    z-index: 1919810;}[data-theme="light"] #fps {    background-color: rgba(255, 255, 255, 0.85);    backdrop-filter: var(--backdrop-filter);    padding: 4px;    border-radius: 4px;}[data-theme="dark"] #fps {    background-color: rgba(0, 0, 0, 0.72);    backdrop-filter: var(--backdrop-filter);    padding: 4px;    border-radius: 4px;}/* 头像呼吸灯 */[data-theme="light"] .avatar-img {    animation: huxi_light 4s ease-in-out infinite;}[data-theme="dark"] .avatar-img {    animation: huxi_dark 4s ease-in-out infinite;}@keyframes huxi_light {    0% {        box-shadow: 0px 0px 1px 1px #e9f5fa;    }    50% {        box-shadow: 0px 0px 5px 5px #e9f5fa;    }    100% {        box-shadow: 0px 0px 1px 1px #e9f5fa;    }}@keyframes huxi_dark {    0% {        box-shadow: 0px 0px 1px 1px #39c5bb;    }    50% {        box-shadow: 0px 0px 5px 5px #39c5bb;    }    100% {        box-shadow: 0px 0px 1px 1px #39c5bb;    }}/* 个人信息卡片背景图 */[data-theme="light"] #aside-content>.card-widget.card-info {    background-image: url(https://sourcebucket.s3.ladydaily.com/img/snowflower.webp);    background-repeat: no-repeat;    background-attachment: inherit;    background-size: 100%;}[data-theme="dark"] #aside-content>.card-widget.card-info {    background-image: url(https://sourcebucket.s3.ladydaily.com/img/aurora.webp);    background-repeat: no-repeat;    background-attachment: inherit;    background-size: 100%;}/* 信息卡片头像状态 */.card-info-avatar .author-status-box {    position: absolute;    bottom: 0;    left: calc(100% - 28px);    width: 28px;    height: 28px;    border: 1px solid #d0d7de;    border-radius: 2em;    background-color: #f8f8f8f8;    transition: 0.4s;    overflow: hidden;}[data-theme="dark"] .card-info-avatar .author-status-box {    background-color: #222222f2;    border: 1px solid #5c6060;}.card-info-avatar .author-status-box .author-status {    display: flex;    align-items: center;    justify-content: center;    height: 28px;    padding: 0 5px;}.card-info-avatar .author-status-box:hover {    width: 105px;}.card-info-avatar .author-status-box:hover .author-status span {    width: 105px;    margin-left: 4px;}.card-info-avatar .author-status-box .author-status span {    width: 0;    font-size: 12px;    height: 100%;    overflow: hidden;    text-overflow: ellipsis;    white-space: nowrap;    transition: 0.4s;}.card-widget .card-info-avatar {    display: inline-block;    position: relative;}/* 博客宽屏适配（自用） *//* 全局宽度 */.layout {    max-width: 1400px;}/* 侧边卡片栏宽度 */.aside-content {    max-width: 318px;    min-width: 300px;}/* 平板尺寸自适应(不启用侧边栏宽度限制) */@media screen and (max-width: 900px) {    .aside-content {        max-width: none !important;        padding: 0 5px 0 5px;    }}/* 除了首页以外其他页面隐藏卡片，并采用宽屏显示 */#archive,#page,#category,#tag {    width: 100%;}.page:not(.page.home) .aside-content {    display: none;}/* 右键菜单 */#rightMenu {    display: none;    position: fixed;    width: 160px;    height: fit-content;    top: 10%;    left: 10%;    /* 菜单面板背景色 */    background-color: var(--card-bg);    /* 菜单面板文字颜色 */    border: 1px solid var(--font-color);    border-radius: 8px;    z-index: 100;}#rightMenu .rightMenu-group {    padding: 7px 6px;}#rightMenu .rightMenu-group:not(:nth-last-child(1)) {    border-bottom: 1px solid var(--font-color);}#rightMenu .rightMenu-group.rightMenu-small {    display: flex;    justify-content: space-between;}#rightMenu .rightMenu-group .rightMenu-item {    height: 30px;    line-height: 30px;    border-radius: 8px;    transition: 0.3s;    color: var(--font-color);}#rightMenu .rightMenu-group.rightMenu-line .rightMenu-item {    display: flex;    height: 40px;    line-height: 40px;    padding: 0 4px;}#rightMenu .rightMenu-group .rightMenu-item:hover {    /* 鼠标悬浮选项颜色 */    background-color: var(--text-bg-hover);}#rightMenu .rightMenu-group .rightMenu-item i {    display: inline-block;    text-align: center;    line-height: 30px;    width: 30px;    height: 30px;    padding: 0 5px;}#rightMenu .rightMenu-group .rightMenu-item span {    line-height: 30px;}#rightMenu .rightMenu-group.rightMenu-line .rightMenu-item * {    height: 40px;    line-height: 40px;}.rightMenu-group.hide {    display: none;}/* 滚动条样式 */::-webkit-scrollbar {    width: 8px;    height: 8px;}::-webkit-scrollbar-track {    background-color: rgba(73, 177, 245, 0.2);    border-radius: 2em;}::-webkit-scrollbar-thumb {    background-color: var(#5ec1e0);    background-image: -webkit-linear-gradient(45deg,            rgba(255, 255, 255, 0.4) 25%,            transparent 25%,            transparent 50%,            rgba(255, 255, 255, 0.4) 50%,            rgba(255, 255, 255, 0.4) 75%,            transparent 75%,            transparent);    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: var(#5ec1e0);}/* tzy页脚样式 */#ft {    max-width: 1200px;    margin: 0 auto 12px;    display: flex;    color: rgb(255 255 255 / 80%) !important;    text-align: left;    flex-wrap: wrap;}.ft-item-1,.ft-item-2 {    display: flex;    height: 100%;    padding: 2px 14px;}.ft-item-1 {    flex-direction: column;    flex: 2;}.ft-item-2 {    flex: 1;    flex-direction: column;}.t-top {    display: flex;}.t-top .t-t-l {    display: flex;    flex-direction: column;    flex: 1.4;    margin-right: 10px;}.t-top .t-t-l .bg-ad {    width: 85%;    border-radius: 10px;    padding: 0 10px;}.btn-xz-box {    margin-top: 10px;}/* 按钮背景颜色等 */.btn-xz {    display: block;    background-color: var(--btn-bg);    color: var(--btn-color);    text-align: center;    line-height: 2.4;    margin: 8px 0;}.btn-xz:hover {    text-decoration: none !important;}/* 按钮悬浮颜色 */.btn-xz-box:hover .btn-xz {    background-color: var(--text-bg-hover);}.t-top .t-t-r {    display: flex;    flex-direction: column;    flex: 1;}.ft-links {    padding: 0 14px;    list-style: none;    margin-top: 0 !important;}.ft-links li a {    display: inline-block !important;    width: 50%;}/* 链接悬浮颜色 */.ft-links li a:hover {    text-decoration: none !important;    color: var(--theme-color) !important;}.ft-item-2 .ft-img-group {    width: 100%;}.ft-t {    font-size: 1.1rem;    margin-bottom: 20px;    line-height: 1;    font-weight: 600;}.t-l-t {    padding-left: 14px;}.ft-item-2 .ft-img-group .img-group-item {    display: inline-block;    width: 18.4%;    margin-right: 14px;    margin-bottom: 6px;}.ft-item-2 .ft-img-group .img-group-item a {    display: inline-block;    width: 100%;    height: 100%;}.ft-item-2 .ft-img-group .img-group-item a img {    width: 100%;    max-height: 80px;    border-radius: 10px;}/* 头像悬浮颜色框 */.ft-item-2 .ft-img-group .img-group-item a img:hover {    border: 2px solid var(--theme-color);}@media screen and (max-width: 768px) {    .ft-item-1 {        flex-basis: 100% !important;    }    .ft-item-2 {        flex-basis: 100% !important;    }    .t-top .t-t-l .bg-ad {        width: 100%;    }}@media screen and (max-width: 576px) {    .t-top {        flex-wrap: wrap;    }    .t-top .t-t-l {        flex-basis: 100% !important;    }    .t-top .t-t-r {        margin-top: 16px;        flex-basis: 100% !important;    }}#footer-wrap a {    border-radius: 30px;}#footer-wrap {    padding: 20px 20px;}/* 页脚心跳动画 */#heartbeat {    color: red;    animation: iconAnimate 1s ease-in-out infinite;}@-moz-keyframes iconAnimate {    0%,    100% {        transform: scale(1);    }    10%,    30% {        transform: scale(0.9);    }    20%,    40%,    60%,    80% {        transform: scale(1.1);    }    50%,    70% {        transform: scale(1.1);    }}@-webkit-keyframes iconAnimate {    0%,    100% {        transform: scale(1);    }    10%,    30% {        transform: scale(0.9);    }    20%,    40%,    60%,    80% {        transform: scale(1.1);    }    50%,    70% {        transform: scale(1.1);    }}@-o-keyframes iconAnimate {    0%,    100% {        transform: scale(1);    }    10%,    30% {        transform: scale(0.9);    }    20%,    40%,    60%,    80% {        transform: scale(1.1);    }    50%,    70% {        transform: scale(1.1);    }}@keyframes iconAnimate {    0%,    100% {        transform: scale(1);    }    10%,    30% {        transform: scale(0.9);    }    20%,    40%,    60%,    80% {        transform: scale(1.1);    }    50%,    70% {        transform: scale(1.1);    }}/* 波浪css */.main-hero-waves-area {    width: 100%;    position: absolute;    left: 0;    bottom: -11px;    z-index: 5;}.waves-area .waves-svg {    width: 100%;    height: 5rem;}/* Animation */.parallax>use {    animation: move-forever 25s cubic-bezier(0.55, 0.5, 0.45, 0.5) infinite;}.parallax>use:nth-child(1) {    animation-delay: -2s;    animation-duration: 7s;    fill: #f7f9febd;}.parallax>use:nth-child(2) {    animation-delay: -3s;    animation-duration: 10s;    fill: #f7f9fe82;}.parallax>use:nth-child(3) {    animation-delay: -4s;    animation-duration: 13s;    fill: #f7f9fe36;}.parallax>use:nth-child(4) {    animation-delay: -5s;    animation-duration: 20s;    fill: #f7f9fe;}/* 黑色模式背景 */[data-theme="dark"] .parallax>use:nth-child(1) {    animation-delay: -2s;    animation-duration: 7s;    fill: #18171dc8;}[data-theme="dark"] .parallax>use:nth-child(2) {    animation-delay: -3s;    animation-duration: 10s;    fill: #18171d80;}[data-theme="dark"] .parallax>use:nth-child(3) {    animation-delay: -4s;    animation-duration: 13s;    fill: #18171d3e;}[data-theme="dark"] .parallax>use:nth-child(4) {    animation-delay: -5s;    animation-duration: 20s;    fill: #18171d;}@keyframes move-forever {    0% {        transform: translate3d(-90px, 0, 0);    }    100% {        transform: translate3d(85px, 0, 0);    }}/*Shrinking for mobile*/@media (max-width: 768px) {    .waves-area .waves-svg {        height: 40px;        min-height: 40px;    }}/* 雪花特效 */[data-theme="light"] #snow {    display: block;    position: fixed;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    z-index: -2;}/* 雪花黑夜模式不显示 */[data-theme="dark"] #snow {    display: none;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe {    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/card_weibo.js"/>
      <url>/js/card_weibo.js</url>
      
        <content type="html"><![CDATA[fetch('https://www.clz-blog.top/api').then(data => data.json()).then(data => {    let html = '<style>.weibo-new{background:#ff3852}.weibo-hot{background:#ff9406}.weibo-jyzy{background:#ffc000}.weibo-recommend{background:#00b7ee}.weibo-adrecommend{background:#febd22}.weibo-friend{background:#8fc21e}.weibo-boom{background:#bd0000}.weibo-topic{background:#ff6f49}.weibo-topic-ad{background:#4dadff}.weibo-boil{background:#f86400}#weibo-container{overflow-y:auto;-ms-overflow-style:none;scrollbar-width:none}#weibo-container::-webkit-scrollbar{display:none}.weibo-list-item{display:flex;flex-direction:row;justify-content:space-between;flex-wrap:nowrap}.weibo-title{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-right:auto}.weibo-num{float:right}.weibo-hotness{display:inline-block;padding:0 6px;transform:scale(.8) translateX(-3px);color:#fff;border-radius:8px}</style>'    html += '<div class="weibo-list">'    let hotness = {        '爆': 'weibo-boom',        '热': 'weibo-hot',        '沸': 'weibo-boil',        '新': 'weibo-new',        '荐': 'weibo-recommend',        '音': 'weibo-jyzy',        '影': 'weibo-jyzy',        '剧': 'weibo-jyzy',        '综': 'weibo-jyzy'    }    for (let item of data) {        html += '<div class="weibo-list-item"><div class="weibo-hotness ' + hotness[(item.hot || '荐')] + '">' + (item.hot || '荐') + '</div>'            + '<span class="weibo-title"><a title="' + item.title + '"href="' + item.url + '" target="_blank" rel="external nofollow noreferrer">' + item.title + '</a></span>'            + '<div class="weibo-num"><span>' + item.num + '</span></div></div>'    }    html += '</div>'    document.getElementById('weibo-container').innerHTML = html}).catch(function (error) {    console.log(error);});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<!-- GitCalendar容器 --><div id="gitZone"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/console.js"/>
      <url>/js/console.js</url>
      
        <content type="html"><![CDATA[var now1 = new Date();function createtime1() {    var grt = new Date("08/09/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间    now1.setTime(now1.getTime() + 250);    var days = (now1 - grt) / 1000 / 60 / 60 / 24;    var dnum = Math.floor(days);    var ascll = [        `欢迎来到Fomalhaut🥝の小家!`,        `Future is now 🍭🍭🍭`,        `        ███████  ██████  ███    ███  █████  ██      ██   ██  █████  ██    ██ ████████ ██      ██    ██ ████  ████ ██   ██ ██      ██   ██ ██   ██ ██    ██    ██    █████   ██    ██ ██ ████ ██ ███████ ██      ███████ ███████ ██    ██    ██    ██      ██    ██ ██  ██  ██ ██   ██ ██      ██   ██ ██   ██ ██    ██    ██    ██       ██████  ██      ██ ██   ██ ███████ ██   ██ ██   ██  ██████     ██                                                 `,        "小站已经苟活",        dnum,        "天啦!",        "©2022 By Fomalhaut",    ];    setTimeout(        console.log.bind(            console,            `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,            "color:#39c5bb",            "",            "color:#39c5bb",            "color:#39c5bb",            "",            "color:#39c5bb",            ""        )    );}createtime1();function createtime2() {    var ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为「大聪明」`, `Photo captured: `, ` 🤪 `];    setTimeout(        console.log.bind(            console,            `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}`,            "color:white; background-color:#10bcc0",            "",            "",            'background:url("https://unpkg.zhimg.com/anzhiyu-assets@latest/image/common/tinggge.gif") no-repeat;font-size:450%'        )    );    setTimeout(console.log.bind(console, "%c WELCOME %c 欢迎光临，大聪明", "color:white; background-color:#23c682", ""));    setTimeout(        console.warn.bind(            console,            "%c ⚡ Powered by Fomalhaut🥝 %c 你正在访问Fomalhaut🥝の小家",            "color:white; background-color:#f0ad4e",            ""        )    );    setTimeout(console.log.bind(console, "%c W23-12 %c 系统监测到你已打开控制台", "color:white; background-color:#4f90d9", ""));    setTimeout(        console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中", "color:white; background-color:#d9534f", "")    );}createtime2();// 重写console方法console.log = function () { };console.error = function () { };console.warn = function () { };]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/day.js"/>
      <url>/js/day.js</url>
      
        <content type="html"><![CDATA[var d = new Date();m = d.getMonth() + 1;dd = d.getDate();y = d.getFullYear();// 公祭日if (m == 9 && dd == 18) {    document.getElementsByTagName("html")[0].setAttribute("style", "filter: grayscale(60%);");    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今天是九一八事变" + (y - 1931).toString() + "周年纪念日\n🪔勿忘国耻，振兴中华🪔");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 7 && dd == 7) {    document.getElementsByTagName("html")[0].setAttribute("style", "filter: grayscale(60%);");    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今天是卢沟桥事变" + (y - 1937).toString() + "周年纪念日\n🪔勿忘国耻，振兴中华🪔");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 12 && dd == 13) {    document.getElementsByTagName("html")[0].setAttribute("style", "filter: grayscale(60%);");    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今天是南京大屠杀" + (y - 1937).toString() + "周年纪念日\n🪔勿忘国耻，振兴中华🪔");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 8 && dd == 14) {    document.getElementsByTagName("html")[0].setAttribute("style", "filter: grayscale(60%);");    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今天是世界慰安妇纪念日\n🪔勿忘国耻，振兴中华🪔");        sessionStorage.setItem("isPopupWindow", "1");    }}// 节假日if (m == 10 && dd <= 3) {//国庆节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("祝祖国" + (y - 1949).toString() + "岁生日快乐！");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 8 && dd == 15) {//搞来玩的，小日子投降    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("小日子已经投降" + (y - 1945).toString() + "年了😃");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 1 && dd == 1) {//元旦节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire(y.toString() + "年元旦快乐！🎉");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 3 && dd == 8) {//妇女节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("各位女神们，妇女节快乐！👩");        sessionStorage.setItem("isPopupWindow", "1");    }}l = ["非常抱歉，因为不可控原因，博客将于明天停止运营！", "好消息，日本没了！", "美国垮了，原因竟然是川普！", "微软垮了！", "你的电脑已经过载，建议立即关机！", "你知道吗？站长很喜欢你哦！", "一分钟有61秒哦", "你喜欢的人跟别人跑了！"]if (m == 4 && dd == 1) {//愚人节，随机谎话    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire(l[Math.floor(Math.random() * l.length)]);        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 5 && dd == 1) {//劳动节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("劳动节快乐\n为各行各业辛勤工作的人们致敬！");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 5 && dd == 4) {//青年节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("青年节快乐\n青春不是回忆逝去,而是把握现在！");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 5 && dd == 20) {//520    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今年是520情人节\n快和你喜欢的人一起过吧！💑");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 7 && dd == 1) {//建党节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("祝中国共产党" + (y - 1921).toString() + "岁生日快乐！");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 9 && dd == 10) {//教师节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("各位老师们教师节快乐！👩‍🏫");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 12 && dd == 25) {//圣诞节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("圣诞节快乐！🎄");        sessionStorage.setItem("isPopupWindow", "1");    }}//传统节日部分if ((y == 2023 && m == 4 && dd == 5) || (y == 2024 && m == 4 && dd == 4) || (y == 2025 && m == 4 && dd == 4)) {//清明节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("清明时节雨纷纷,一束鲜花祭故人💐");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((y == 2023 && m == 12 && dd == 22) || (y == 2024 && m == 12 && dd == 21) || (y == 2025 && m == 12 && dd == 21)) {//冬至    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("冬至快乐\n快吃上一碗热热的汤圆和饺子吧🧆");        sessionStorage.setItem("isPopupWindow", "1");    }}var lunar = calendarFormatter.solar2lunar();//农历采用汉字计算，防止出现闰月导致问题if ((lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初六") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初五") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初四") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初三") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初二") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初一") || (lunar["IMonthCn"] == "腊月" && lunar["IDayCn"] == "三十") || (lunar["IMonthCn"] == "腊月" && lunar["IDayCn"] == "廿九")) {    //春节，本来只有大年三十到初六，但是有时候除夕是大年二十九，所以也加上了    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire(y.toString() + "年新年快乐\n🎊祝你心想事成，诸事顺利🎊");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "十五")) {    //元宵节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("元宵节快乐\n送你一个大大的灯笼🧅");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "五月" && lunar["IDayCn"] == "初五")) {    //端午节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("端午节快乐\n请你吃一条粽子🍙");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "七月" && lunar["IDayCn"] == "初七")) {    //七夕节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("七夕节快乐\n黄昏后,柳梢头,牛郎织女来碰头");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "八月" && lunar["IDayCn"] == "十五")) {    //中秋节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("中秋节快乐\n请你吃一块月饼🍪");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "九月" && lunar["IDayCn"] == "初九")) {    //重阳节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("重阳节快乐\n独在异乡为异客，每逢佳节倍思亲");        sessionStorage.setItem("isPopupWindow", "1");    }}// 切换主题提醒// if (y == 2022 && m == 12 && (dd >= 18 && dd <= 20)) {//     if (sessionStorage.getItem("isPopupWindow") != "1") {//         Swal.fire("网站换成冬日限定主题啦⛄");//         sessionStorage.setItem("isPopupWindow", "1");//     }// }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) { }    return "";};class Cursor {    constructor() {        this.pos = { curr: null, prev: null };        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(57, 197, 187)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = { curr: null, prev: null };        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove = e => { (this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = { x: e.clientX - 8, y: e.clientY - 8 }; this.cursor.classList.remove("hidden"); };        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown = e => this.cursor.classList.add("active");        document.onmouseup = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/light.js"/>
      <url>/js/light.js</url>
      
        <content type="html"><![CDATA[// 霓虹灯效果// 颜色数组var arr = ["#39c5bb", "#f14747", "#f1a247", "#f1ee47", "#b347f1", "#1edbff", "#ed709b", "#5636ed"];// 颜色索引var idx = 0;// 切换颜色function changeColor() {    // 仅夜间模式才启用    if (document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark') {        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = arr[idx] + " 0 0 10px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = arr[idx] + " 0 0 5px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = arr[idx] + " 0 0 12px";            document.getElementsByClassName("author-info__description")[0].style.textShadow = arr[idx] + " 0 0 12px";        } catch {        }        idx++;        if (idx == 8) {            idx = 0;        }    } else {        // 白天模式恢复默认        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = "#1e1e1ee0 1px 1px 1px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = "";            document.getElementsByClassName("author-info__description")[0].style.textShadow = "";        } catch {        }    }}// 开启计时器window.onload = setInterval(changeColor, 1200);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/fps.js"/>
      <url>/js/fps.js</url>
      
        <content type="html"><![CDATA[if (window.localStorage.getItem("fpson") == undefined || window.localStorage.getItem("fpson") == "1") {    var rAF = function () {        return (            window.requestAnimationFrame ||            window.webkitRequestAnimationFrame ||            function (callback) {                window.setTimeout(callback, 1000 / 60);            }        );    }();    var frame = 0;    var allFrameCount = 0;    var lastTime = Date.now();    var lastFameTime = Date.now();    var loop = function () {        var now = Date.now();        var fs = (now - lastFameTime);        var fps = Math.round(1000 / fs);        lastFameTime = now;        // 不置 0，在动画的开头及结尾记录此值的差值算出 FPS        allFrameCount++;        frame++;        if (now > 1000 + lastTime) {            var fps = Math.round((frame * 1000) / (now - lastTime));            if (fps <= 5) {                var kd = `<span style="color:#bd0000">卡成ppt🤢</span>`            } else if (fps <= 15) {                var kd = `<span style="color:red">电竞级帧率😖</span>`            } else if (fps <= 25) {                var kd = `<span style="color:orange">有点难受😨</span>`            } else if (fps < 35) {                var kd = `<span style="color:#9338e6">不太流畅🙄</span>`            } else if (fps <= 45) {                var kd = `<span style="color:#08b7e4">还不错哦😁</span>`            } else {                var kd = `<span style="color:#39c5bb">十分流畅🤣</span>`            }            document.getElementById("fps").innerHTML = `FPS:${fps} ${kd}`;            frame = 0;            lastTime = now;        };        rAF(loop);    }    loop();} else {    document.getElementById("fps").style = "display:none!important"}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/readPercent.js"/>
      <url>/js/readPercent.js</url>
      
        <content type="html"><![CDATA[window.onscroll = percent;// 执行函数// 页面百分比function percent() {    let a = document.documentElement.scrollTop || window.pageYOffset, // 卷去高度        b = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - document.documentElement.clientHeight, // 整个网页高度        result = Math.round(a / b * 100), // 计算百分比        up = document.querySelector("#go-up") // 获取按钮    if (result <= 95) {        up.childNodes[0].style.display = 'none'        up.childNodes[1].style.display = 'block'        up.childNodes[1].innerHTML = result;    } else {        up.childNodes[1].style.display = 'none'        up.childNodes[0].style.display = 'block'    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime-copy.js"/>
      <url>/js/runtime-copy.js</url>
      
        <content type="html"><![CDATA[var now = new Date;function createtime() {    now.setTime(now.getTime() + 1e3);    var e = new Date("08/01/2022 00:00:00"),        t = Math.trunc(234e8 + (now - e) / 1e3 * 17),        a = (t / 1496e5)            .toFixed(6),        o = new Date("08/09/2022 00:00:00"),        n = (now - o) / 1e3 / 60 / 60 / 24,        r = Math.floor(n),        i = (now - o) / 1e3 / 60 / 60 - 24 * r,        s = Math.floor(i);    1 == String(s)        .length && (s = "0" + s);    var d = (now - o) / 1e3 / 60 - 1440 * r - 60 * s,        l = Math.floor(d);    1 == String(l)        .length && (l = "0" + l);    var g = (now - o) / 1e3 - 86400 * r - 3600 * s - 60 * l,        b = Math.round(g);    1 == String(b)        .length && (b = "0" + b);    let c = "";    c = s < 18 && s >= 9 ? `<img class='boardsign' src='https://sourcebucket.s3.ladydaily.com/badge/F小屋-科研摸鱼中.svg' title='什么时候能够实现财富自由呀~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>` : `<img class='boardsign' src='https://sourcebucket.s3.ladydaily.com/badge/F小屋-下班休息啦.svg' title='下班了就该开开心心地玩耍~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>`, document.getElementById("workboard") && (document.getElementById("workboard")        .innerHTML = c)}setInterval((() => {    createtime()}), 1e3);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[var now = new Date();function createtime() {    // 当前时间    now.setTime(now.getTime() + 1000);    var start = new Date("08/01/2022 00:00:00"); // 旅行者1号开始计算的时间    var dis = Math.trunc(23400000000 + ((now - start) / 1000) * 17); // 距离=秒数*速度 记住转换毫秒    var unit = (dis / 149600000).toFixed(6);  // 天文单位    var grt = new Date("08/09/2022 00:00:00");// 网站诞生时间    var days = (now - grt) / 1e3 / 60 / 60 / 24,        dnum = Math.floor(days),        hours = (now - grt) / 1e3 / 60 / 60 - 24 * dnum,        hnum = Math.floor(hours);    1 == String(hnum).length && (hnum = "0" + hnum);    var minutes = (now - grt) / 1e3 / 60 - 1440 * dnum - 60 * hnum,        mnum = Math.floor(minutes);    1 == String(mnum).length && (mnum = "0" + mnum);    var seconds = (now - grt) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,        snum = Math.round(seconds);    1 == String(snum).length && (snum = "0" + snum);    let currentTimeHtml = "";    (currentTimeHtml =        hnum < 18 && hnum >= 9            ? `<img class='boardsign' src='https://sourcebucket.s3.ladydaily.com/badge/F小屋-科研摸鱼中.svg' title='什么时候能够实现财富自由呀~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${dnum} 天 ${hnum} 小时 ${mnum} 分 ${snum} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${dis} 千米，约为 ${unit} 个天文单位 🚀</div>`            : `<img class='boardsign' src='https://sourcebucket.s3.ladydaily.com/badge/F小屋-下班休息啦.svg' title='下班了就该开开心心地玩耍~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${dnum} 天 ${hnum} 小时 ${mnum} 分 ${snum} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${dis} 千米，约为 ${unit} 个天文单位 🚀</div>`),        document.getElementById("workboard") &&        (document.getElementById("workboard").innerHTML = currentTimeHtml);}// 设置重复执行函数，周期1000mssetInterval(() => {    createtime();}, 1000);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/snow.js"/>
      <url>/js/snow.js</url>
      
        <content type="html"><![CDATA[if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {    // 移动端不显示} else {    // document.write('<canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:-2;pointer-events:none"></canvas>');    window && (() => {        let e = {            flakeCount: 50, // 雪花数目            minDist: 150,   // 最小距离            color: "255, 255, 255", // 雪花颜色            size: 1.5,  // 雪花大小            speed: .5,  // 雪花速度            opacity: .7,    // 雪花透明度            stepsize: .5    // 步距        };        const t = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {            window.setTimeout(e, 1e3 / 60)        }            ;        window.requestAnimationFrame = t;        const i = document.getElementById("snow"),            n = i.getContext("2d"),            o = e.flakeCount;        let a = -100,            d = -100,            s = [];        i.width = window.innerWidth,            i.height = window.innerHeight;        const h = () => {            n.clearRect(0, 0, i.width, i.height);            const r = e.minDist;            for (let t = 0; t < o; t++) {                let o = s[t];                const h = a,                    w = d,                    m = o.x,                    c = o.y,                    p = Math.sqrt((h - m) * (h - m) + (w - c) * (w - c));                if (p < r) {                    const e = (h - m) / p,                        t = (w - c) / p,                        i = r / (p * p) / 2;                    o.velX -= i * e,                        o.velY -= i * t                } else                    o.velX *= .98,                        o.velY < o.speed && o.speed - o.velY > .01 && (o.velY += .01 * (o.speed - o.velY)),                        o.velX += Math.cos(o.step += .05) * o.stepSize;                n.fillStyle = "rgba(" + e.color + ", " + o.opacity + ")",                    o.y += o.velY,                    o.x += o.velX,                    (o.y >= i.height || o.y <= 0) && l(o),                    (o.x >= i.width || o.x <= 0) && l(o),                    n.beginPath(),                    n.arc(o.x, o.y, o.size, 0, 2 * Math.PI),                    n.fill()            }            t(h)        }            , l = e => {                e.x = Math.floor(Math.random() * i.width),                    e.y = 0,                    e.size = 3 * Math.random() + 2,                    e.speed = 1 * Math.random() + .5,                    e.velY = e.speed,                    e.velX = 0,                    e.opacity = .5 * Math.random() + .3            }            ;        document.addEventListener("mousemove", (e => {            a = e.clientX,                d = e.clientY        }        )),            window.addEventListener("resize", (() => {                i.width = window.innerWidth,                    i.height = window.innerHeight            }            )),            (() => {                for (let t = 0; t < o; t++) {                    const t = Math.floor(Math.random() * i.width)                        , n = Math.floor(Math.random() * i.height)                        , o = 3 * Math.random() + e.size                        , a = 1 * Math.random() + e.speed                        , d = .5 * Math.random() + e.opacity;                    s.push({                        speed: a,                        velX: 0,                        velY: a,                        x: t,                        y: n,                        size: o,                        stepSize: Math.random() / 30 * e.stepsize,                        step: 0,                        angle: 180,                        opacity: d                    })                }                h()            }            )()    }    )();}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/lunar.js"/>
      <url>/js/lunar.js</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () {    if (document.hidden) {        //离开当前页面时标签显示内容        document.title = '👀跑哪里去了~';        clearTimeout(titleTime);    } else {        //返回当前页面时标签显示内容        document.title = '🐖抓到你啦～';        //两秒后变回正常标题        titleTime = setTimeout(function () {            document.title = OriginTitile;        }, 2000);    }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() { window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; var n, e, i, h, t = .05, s = document.getElementById("universe"), o = !0, a = "180,184,240", r = "226,225,142", d = "226,225,224", c = []; function f() { n = window.innerWidth, e = window.innerHeight, i = .216 * n, s.setAttribute("width", n), s.setAttribute("height", e) } function u() { h.clearRect(0, 0, n, e); for (var t = c.length, i = 0; i < t; i++) { var s = c[i]; s.move(), s.fadeIn(), s.fadeOut(), s.draw() } } function y() { this.reset = function () { this.giant = m(3), this.comet = !this.giant && !o && m(10), this.x = l(0, n - 10), this.y = l(0, e), this.r = l(1.1, 2.6), this.dx = l(t, 6 * t) + (this.comet + 1 - 1) * t * l(50, 120) + 2 * t, this.dy = -l(t, 6 * t) - (this.comet + 1 - 1) * t * l(50, 120), this.fadingOut = null, this.fadingIn = !0, this.opacity = 0, this.opacityTresh = l(.2, 1 - .4 * (this.comet + 1 - 1)), this.do = l(5e-4, .002) + .001 * (this.comet + 1 - 1) }, this.fadeIn = function () { this.fadingIn && (this.fadingIn = !(this.opacity > this.opacityTresh), this.opacity += this.do) }, this.fadeOut = function () { this.fadingOut && (this.fadingOut = !(this.opacity < 0), this.opacity -= this.do / 2, (this.x > n || this.y < 0) && (this.fadingOut = !1, this.reset())) }, this.draw = function () { if (h.beginPath(), this.giant) h.fillStyle = "rgba(" + a + "," + this.opacity + ")", h.arc(this.x, this.y, 2, 0, 2 * Math.PI, !1); else if (this.comet) { h.fillStyle = "rgba(" + d + "," + this.opacity + ")", h.arc(this.x, this.y, 1.5, 0, 2 * Math.PI, !1); for (var t = 0; t < 30; t++)h.fillStyle = "rgba(" + d + "," + (this.opacity - this.opacity / 20 * t) + ")", h.rect(this.x - this.dx / 4 * t, this.y - this.dy / 4 * t - 2, 2, 2), h.fill() } else h.fillStyle = "rgba(" + r + "," + this.opacity + ")", h.rect(this.x, this.y, this.r, this.r); h.closePath(), h.fill() }, this.move = function () { this.x += this.dx, this.y += this.dy, !1 === this.fadingOut && this.reset(), (this.x > n - n / 4 || this.y < 0) && (this.fadingOut = !0) }, setTimeout(function () { o = !1 }, 50) } function m(t) { return Math.floor(1e3 * Math.random()) + 1 < 10 * t } function l(t, i) { return Math.random() * (i - t) + t } f(), window.addEventListener("resize", f, !1), function () { h = s.getContext("2d"); for (var t = 0; t < i; t++)c[t] = new y, c[t].reset(); u() }(), function t() { document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark' && u(), window.requestAnimationFrame(t) }() };dark()]]></content>
      
    </entry>
    
    
  
</search>
