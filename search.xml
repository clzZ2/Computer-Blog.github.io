<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaSE面试(八股文)</title>
      <link href="/2023/01/01/JavaSE%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/01/JavaSE%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaSE面试-八股文"><a href="#JavaSE面试-八股文" class="headerlink" title="JavaSE面试(八股文)"></a>JavaSE面试(八股文)</h1><h1 id="01-JavaSE面试"><a href="#01-JavaSE面试" class="headerlink" title="01 JavaSE面试"></a>01 JavaSE面试</h1><h2 id="chapter01-Java语言"><a href="#chapter01-Java语言" class="headerlink" title="chapter01 Java语言"></a>chapter01 Java语言</h2><h4 id="01-Java语言具有哪些特点？"><a href="#01-Java语言具有哪些特点？" class="headerlink" title="01 Java语言具有哪些特点？"></a>01 Java语言具有哪些特点？</h4><p>&nbsp;<br><br>&nbsp;<br></p><h2 id="chapter02"><a href="#chapter02" class="headerlink" title="chapter02"></a>chapter02</h2><p>&nbsp;<br><br>&nbsp;<br></p><h2 id="chapter21-异常"><a href="#chapter21-异常" class="headerlink" title="chapter21 异常"></a>chapter21 异常</h2><h4 id="01-简述Java异常的分类"><a href="#01-简述Java异常的分类" class="headerlink" title="01. 简述Java异常的分类"></a>01. 简述Java异常的分类</h4><blockquote><p>​    ==Java异常分为Error（程序无法处理的错误），Exception（程序本身可以处理的异常），这两个类均继承Throwable==</p><p>​    Error常见的有<code>StackOverFlowError、OutOfMemoryError</code>等；</p><p>​    Exception可分为 ==运行时异常== 和 ==非运行时异常== ；</p><p>​    对于运行时异常，可以利用 ==try~catch== 的方式进行处理，也可以不处理；</p><p>​    对于编译时异常，必须处理，不处理的话程序无法通过编译；</p></blockquote><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div><!-- ![异常的继承结构图](01 JavaSE面试.assets/异常的继承结构图.png) --><p><img src="01 JavaSE面试.assets/异常的继承结构图.png" alt="异常的继承结构图" style="zoom:50%;" /></p><p><img src="01 JavaSE面试.assets/image-20220428104728285.png" alt="image-20220428104728285" style="zoom:50%;" /></p><p><img src="01 JavaSE面试.assets/image-20220428104750178.png" alt="image-20220428104750178" style="zoom:50%;" /></p><p>&nbsp;<br></p><h4 id="02-简述throw和throws的区别"><a href="#02-简述throw和throws的区别" class="headerlink" title="02. 简述throw和throws的区别"></a>02. 简述throw和throws的区别</h4><blockquote><p><strong>作用位置：</strong></p><p>​    throw在方法体内部，throws在方法签名处、声明处；</p><p><strong>作用对象：</strong></p><p>​    throw抛出具体异常对象，throws声明可能抛出异常的异常类型；</p><p><strong>作用效果：</strong></p><p>​    throw每次只能抛出一个异常对象（源头，制造异常），throws代表该方法可能会抛出的异常列表（提醒调用者）；</p></blockquote><p>&nbsp;<br></p><h4 id="03-简述final、finally、finalize的区别"><a href="#03-简述final、finally、finalize的区别" class="headerlink" title="03. 简述final、finally、finalize的区别"></a>03. 简述final、finally、finalize的区别</h4><blockquote><p>​    final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承</p><p>​    finally 用于抛异常，finally代码块内语句无论是否发生异常，都会在执行finally，常用于一些流的关闭。</p><p>​    finalize方法用于垃圾回收。</p><p>​    一般情况下不需要我们实现 finalize，当对象被回收的时候需要释放一些资源，比如socket链接，在对象初始化时创建，整个生命周期内有效，那么需要实现 finalize 方法，关闭这个链接。</p><p>​    但是当调用finalize方法后，并不意味着gc会立即回收该对象，所以有可能真正调用的时候，对象又不需要回收了，然后到了真正要回收的时候，因为之前调用过一次，这次又不会调用了，产生问题。所以，不推荐使用finalize方法。</p></blockquote><p>&nbsp;<br></p><h4 id="04-try-中-return-了，finally-还会执行吗？"><a href="#04-try-中-return-了，finally-还会执行吗？" class="headerlink" title="04. try 中 return 了，finally 还会执行吗？"></a>04. try 中 return 了，finally 还会执行吗？</h4><blockquote><p>​    会执行，并且finally的执行早于try里面return</p><p>结论：</p><ul><li>① 不管有木有出现异常，finally块中代码都会执行；</li><li>② 当 try 和 catch 中有 return 时，finally 仍然会执行；</li><li>③ finally 是在 return 后面的表达式运算后执行的 (此时并没有返回运算后的值，而是先把要返回的值保存起来，管</li></ul><p>finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值)，所以函数返回值是在 finally 执行前确定的；</p><ul><li>④ finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值；</li></ul></blockquote><p>&nbsp;<br></p><h4 id="05-finally代码块是否一定会执行？"><a href="#05-finally代码块是否一定会执行？" class="headerlink" title="05. finally代码块是否一定会执行？"></a>05. finally代码块是否一定会执行？</h4><blockquote><p>当遇到下面情况不会执行。</p><ul><li><p>① 当程序在进入try语句块之前就出现异常时会直接结束。</p></li><li><p>② 当程序在try块中强制退出时，如使用 <code>System.exit(0)</code>，也不会执行finally块中的代码。</p></li></ul><p>​    其它情况下，在<code>try/catch/finally</code>语句执行的时候，try块先执行，</p><ul><li>当有异常发生，catch和finally进行处理后程序就结束了，</li><li><p>当没有异常发生，在执行完finally中的代码后，后面代码会继续执行。</p><p> 值得注意的是，当try/catch语句块中有return时，finally语句块中的代码会在return之前执行。</p></li></ul><p>​    如果try/catch/finally块中都有return语句，finally块中的return语句会覆盖try/catch模块中的return语句。</p></blockquote><p>&nbsp;<br></p><h4 id="06-简述常见的异常类"><a href="#06-简述常见的异常类" class="headerlink" title="06. 简述常见的异常类"></a>06. 简述常见的异常类</h4><blockquote><p>1.NullPointerException：空指针异常；</p><p>2.SQLException：数据库相关的异常；</p><p>3.IndexOutOfBoundsException：数组下角标越界异常；</p><p>4.FileNotFoundException：打开文件失败时抛出；</p><p>5.IOException：当发生某种IO异常时抛出；</p><p>6.ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出此异常；</p><p>7.NoSuchMethodException：无法找到某一方法时，抛出；</p><p>8.ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常；</p><p>9.NumberFormatException：当试图将字符串转换成数字时，失败了，抛出；</p><p>10.IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。</p><p>11.ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</p></blockquote><p>&nbsp;<br></p><h4 id="07-自定义异常在生产中如何应用"><a href="#07-自定义异常在生产中如何应用" class="headerlink" title="07. 自定义异常在生产中如何应用"></a>07. 自定义异常在生产中如何应用</h4><blockquote><p>​    Java虽然提供了丰富的异常处理类，但是在项目中还会经常使用自定义异常，其主要原因是Java提供的异常类在某些情况下还</p><p>是不能满足实际需球。</p><p>例如以下情况：</p><ul><li><p>① 系统中有些错误是符合Java语法，但不符合业务逻辑。</p></li><li><p>② 在分层的软件结构中，通常是在表现层统一对系统其他层次的异常进行捕获处理。</p></li></ul></blockquote><p>&nbsp;<br><br>&nbsp;<br></p><h2 id="chapter22-集合与泛型"><a href="#chapter22-集合与泛型" class="headerlink" title="chapter22 集合与泛型"></a>chapter22 集合与泛型</h2><h4 id="01-简述泛型"><a href="#01-简述泛型" class="headerlink" title="01. 简述泛型"></a>01. 简述泛型</h4><blockquote><p>​    泛型，即 “参数化类型”，解决不确定对象具体类型的问题，在编译阶段有效。</p><p>​    在泛型使用过程中，操作的数据类型被指定为一个参数，这个参数类型在类中称为泛型类、接口中称为泛型接口、方法中称为泛</p><p>型方法。</p></blockquote><p>泛型是Java SE1.5之后的特性，《Java 核心技术》中对泛型的定义是：</p><blockquote><p>“泛型”意味着编写的代码==可以被不同类型的对象所重用==</p></blockquote><p>“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的</p><p>ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如<code>Iteger、String</code>，自定义的各种类型等。但在我们使用的使用通</p><p>过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; iniData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>使用泛型的好处</strong></p><blockquote><p>​    以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了</p><p>Object即可，添加的数据全部都可向上转型为Object。更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。</p></blockquote><p>&nbsp;<br></p><h4 id="02-简述泛型擦除"><a href="#02-简述泛型擦除" class="headerlink" title="02. 简述泛型擦除"></a>02. 简述泛型擦除</h4><blockquote><p>​    Java编译器生成的字节码是不包含泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为泛型擦除。</p></blockquote><p>&nbsp;<br></p><h4 id="03-简述Java容器种类"><a href="#03-简述Java容器种类" class="headerlink" title="03. 简述Java容器种类"></a>03. 简述Java容器种类</h4><p><strong>Collection继承结构图</strong></p><p><img src="01 JavaSE面试.assets/Collection结构图.png" alt="Collection结构图" style="zoom:50%;" /></p><p><strong>Map结构图</strong></p><p><img src="01 JavaSE面试.assets/Map结构图.png" alt="Map结构图" style="zoom:50%;" /></p><p>&nbsp;<br></p><h4 id="04-简述Collection和Collections的区别"><a href="#04-简述Collection和Collections的区别" class="headerlink" title="04. 简述Collection和Collections的区别"></a>04. 简述Collection和Collections的区别</h4><blockquote><p>1.Collection是最基本的集合接口，Collection派生了两个子接口list和set，分别定义了两种不同的存储方式；</p><p>2.Colleections是包装类（集合工具类），它包含各种有关集合操作的静态方法（对集合的搜索、排序、线程安全化等）；</p><p>此类不能实例化，就像一个工具类，服务于Collection框架。</p></blockquote><p>&nbsp;<br></p><h4 id="05-简述Java的List"><a href="#05-简述Java的List" class="headerlink" title="05. 简述Java的List"></a>05. 简述Java的List</h4><blockquote><p>​    List是一个有序队列，在JAVA中有两种实现方式：</p><ul><li>① ==ArrayList== 使用数组实现，是容量可变的非线程安全列表，随机访问快，集合扩容时会创建更大的数组，把原有数组复制到新数组。</li><li>② ==LinkedList== 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。</li></ul></blockquote><p>&nbsp;<br></p><h4 id="06-简述ArrayList、LinkedList和Vector的共同点与区别"><a href="#06-简述ArrayList、LinkedList和Vector的共同点与区别" class="headerlink" title="06. 简述ArrayList、LinkedList和Vector的共同点与区别"></a>06. 简述ArrayList、LinkedList和Vector的共同点与区别</h4><blockquote><p>​    ① ArrayList、Vector 和 LinkedList 都是可以 ==动态改变长度的数组。==</p><p>​    ② ArrayList和Vector都是基于存储元素的 Object[] array来实现的，</p><p>​    它们会在内存中开辟一块连续的空间来存储，支持下标、索引访问。</p><p>​    但在涉及插入元素时可能需要移动容器中的元素，插入效率较低。</p><p>​    当存储元素超过容器的初始化容量大小，ArrayList与Vector均会进行扩容。</p><p>​    ③ LinkedList采用双向列表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，</p><p>​    但在插入元素的时候不需要对数据进行移动，插入效率较高。</p><p>​    ④  Vector是线程安全的，其大部分方法是直接或间接同步的。</p><p>​    ArrayList不是线程安全的，其方法不具有同步性质。LinkedList也不是线程安全的。</p></blockquote><p><img src="01 JavaSE面试.assets/image-20220428111054604.png" alt="image-20220428111054604" style="zoom:50%;" /></p><p>&nbsp;<br></p><h4 id="07-简述Java的Set"><a href="#07-简述Java的Set" class="headerlink" title="07. 简述Java的Set"></a>07. 简述Java的Set</h4><blockquote><p>​    Set 即集合，该数据结构不允许元素重复且无序。JAVA对Set有三种实现方式：</p><p>​    ① ==HashSet== 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，Value系统自定义一个名为 PRESENT 的 Object 类型常量。判断元素是否相同时，先比较hashCode，相同后再利用equals比较，查询 O(1)</p><p>​    ② ==LinkedHashSet== 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。</p><p>​    ③ ==TreeSet== 通过 TreeMap 实现的，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。查询 O(logn)</p></blockquote><p>&nbsp;<br></p><h4 id="08-简述HashSet中equals与hashCode的关系"><a href="#08-简述HashSet中equals与hashCode的关系" class="headerlink" title="08. 简述HashSet中equals与hashCode的关系"></a>08. 简述HashSet中equals与hashCode的关系</h4><blockquote><p>​    equals和hashCode这两个方法都是从object类中继承过来的，equals主要用于判断对象的内存地址引用是否是同一个地址；</p><p>​    hashCode根据定义的哈希规则将对象的内存地址转换为一个哈希码。</p><p>​    HashSet中存储的元素是不能重复的，主要通过hashCode与equals两个方法来判断存储的对象是否相同：</p><ol><li>如果两个对象的hashCode值不同，说明两个对象不相同。</li><li>如果两个对象的hashCode值相同，接着会调用对象的equals方法，如果equlas方法的返回结果为true，那么说明两个对象相同，否则不相同。</li></ol></blockquote><p>&nbsp;<br></p><h4 id="09-简述java的TreeMap"><a href="#09-简述java的TreeMap" class="headerlink" title="09. 简述java的TreeMap"></a>09. 简述java的TreeMap</h4><blockquote><p>​    ==TreeMap== 是底层利用红黑树实现的Map结构，底层实现是一棵平衡的排序二叉树，由于红黑树的插入、删除、遍历时间复杂度都为O(logN)，所以性能上低于哈希表。</p><p>​    但是哈希表无法提供键值对的有序输出，红黑树可以按照键的值的大小有序输出。</p></blockquote><p>&nbsp;<br></p><h4 id="10-简述JAVA的HashMap，JDK1-7与1-8的区别"><a href="#10-简述JAVA的HashMap，JDK1-7与1-8的区别" class="headerlink" title="10. 简述JAVA的HashMap，JDK1.7与1.8的区别"></a>10. 简述JAVA的HashMap，JDK1.7与1.8的区别</h4><blockquote><p>​    JDK8 之前底层实现是数组 + 链表，JDK8 改为数组 + 链表/红黑树。主要成员变量包括存储数据的table 数组、元素数量 size、</p><p>加载因子 loadFactor。</p><p>​    HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的hash 值一样，就会发生哈希</p><p>冲突，被放到同一个链表上。</p><p>​    table 数组记录 HashMap 的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链表，Node/Entry 节点包</p><p>含四个成员变量：key、value、next 指针和 hash 值。在JDK8后链表超过8会转化为红黑树。</p><p>​    若当前数据/总数据容量&gt;负载因子，Hashmap将执行扩容操作。</p><p>​    默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1&lt;&lt; 30 、默认加载因子为 0.75。</p></blockquote><p>&nbsp;<br></p><h4 id="11-简述HashMap和HashTable的区别"><a href="#11-简述HashMap和HashTable的区别" class="headerlink" title="11. 简述HashMap和HashTable的区别"></a>11. 简述HashMap和HashTable的区别</h4><blockquote><p>1.HashMap是线程不安全的，HashTable是线程安全的；在多线程访问HashMap需要提供额外的同步机制。</p><p>2.HashMap是Hashtable的轻量级实现，HashMap中运行键和值为null（最多一个key为null），HashTable不允许；</p><p>3.HashTable的默认容量是16，以2的倍数扩容；HashTable是11，以2*n+1扩容；（扩容因子：0.75）</p><p>4.Hashtable使用Enumeration进行遍历，HashMap使用Iterator进行遍历。</p></blockquote><p><img src="01 JavaSE面试.assets/image-20220428111121161.png" alt="image-20220428111121161" style="zoom:50%;" /></p><p>&nbsp;<br></p><h4 id="12-简述何时使用HashMap、TreeMap"><a href="#12-简述何时使用HashMap、TreeMap" class="headerlink" title="12. 简述何时使用HashMap、TreeMap"></a>12. 简述何时使用HashMap、TreeMap</h4><blockquote><p>​    如果对Map进行插入、删除或定位一个元素的操作更频繁，HashMap是更好的选择。</p><p>​    如果需要对key集合进行有序的遍历，TreeMap是更好的选择。</p></blockquote><p>&nbsp;<br></p><h4 id="13-简述下List、Set、Map三种的区别"><a href="#13-简述下List、Set、Map三种的区别" class="headerlink" title="13. 简述下List、Set、Map三种的区别"></a>13. 简述下List、Set、Map三种的区别</h4><blockquote><p>​    <strong>List(对付顺序的好帮手)</strong>：List接口存储一组不唯一(可以有多个元素引用相同的对象)，有序的对象</p><p>​    <strong>Set(注重独—无二的性质)</strong>：不允许重复的集合。不会有多个元素引用相同的对象。</p><p>​    <strong>Map(用Key来搜索的专家)</strong>：使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重</p><p>复，典型的Key是String类型，但也可以是任何对象。</p></blockquote><p>&nbsp;<br></p><h4 id="15-简述Java中线程安全的数据结构"><a href="#15-简述Java中线程安全的数据结构" class="headerlink" title="15. 简述Java中线程安全的数据结构"></a>15. 简述Java中线程安全的数据结构</h4><blockquote><p>​    HashTable： 哈希表的线程安全版，效率低</p><p>​    ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代HashTable</p><p>​    Vector：线程安全版Arraylist</p><p>​    Stack：线程安全版栈</p><p>​    BlockingQueue及其子类：线程安全版队列</p></blockquote><p>&nbsp;<br></p><h4 id="16-为何HashMap线程不安全？"><a href="#16-为何HashMap线程不安全？" class="headerlink" title="16. 为何HashMap线程不安全？"></a>16. 为何HashMap线程不安全？</h4><blockquote><p>​    在JDK1.7中，HashMap采用头插法插入元素，因此并发情况下会导致环形链表，产生死循环。</p><p>​    虽然JDK1.8采用了尾插法解决了这个问题，但是并发下的put操作也会使前一个key被后一个key覆盖。由于HashMap有扩容机制</p><p>存在，也存在A线程进行扩容后，B线程执行get方法出现失误的情况。</p></blockquote><p>&nbsp;<br></p><h4 id="17-为何集合类没有实现Cloneable和Serializable接口？"><a href="#17-为何集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="17. 为何集合类没有实现Cloneable和Serializable接口？"></a>17. 为何集合类没有实现Cloneable和Serializable接口？</h4><blockquote><p>​    克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。</p><p>​    因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p></blockquote><p>&nbsp;<br></p><h4 id="21-简述JAVA的迭代器-Iterator"><a href="#21-简述JAVA的迭代器-Iterator" class="headerlink" title="21. 简述JAVA的迭代器(Iterator)"></a>21. 简述JAVA的迭代器(Iterator)</h4><blockquote><p>​    Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。</p><p>​    迭代器可以在迭代的过程中删除底层集合的元素，但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。</p></blockquote><p>&nbsp;<br></p><h4 id="22-简述fail-fast和fail-safe迭代器的区别"><a href="#22-简述fail-fast和fail-safe迭代器的区别" class="headerlink" title="22. 简述fail-fast和fail-safe迭代器的区别"></a>22. 简述fail-fast和fail-safe迭代器的区别</h4><blockquote><p>​    ① ==fail-fast== 直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，</p><p>​    就会立刻抛出ConcurrentModificationException异常从而导致遍历失败。</p><p>​    常见的使用fail-fast方式的容器有 <code>HashMap</code> 和 <code>ArrayList</code> 等。</p><p>​    ② ==fail-safe== 这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。</p><p>​    常见的使用fail-safe方式遍历的容器有 <code>ConcurrentHashMap</code> 和 <code>CopyOnWriteArrayList</code>。</p></blockquote><p><img src="01 JavaSE面试.assets/image-20220428112519832.png" alt="image-20220428112519832" style="zoom:50%;" /></p><h4 id="25-简述Java优先级队列-Priority-Queue"><a href="#25-简述Java优先级队列-Priority-Queue" class="headerlink" title="25. 简述Java优先级队列(Priority Queue)"></a>25. 简述Java优先级队列(Priority Queue)</h4><blockquote><p>​    PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。</p><p>​    在创建的时候，我们可以给它提供一个负责给元素排序的比较器。</p><p>​    PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。</p><p>​    最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。</p></blockquote><p>&nbsp;<br></p><h2 id="chapter23-IO"><a href="#chapter23-IO" class="headerlink" title="chapter23 IO"></a>chapter23 IO</h2><h4 id="01-简述Java中的IO流"><a href="#01-简述Java中的IO流" class="headerlink" title="01. 简述Java中的IO流"></a>01. 简述Java中的IO流</h4><blockquote><p>1、按流划分：输入流和输出流；</p><p>2、按操作单位划分：字节流和字符流；</p><p>​    字节流：inputStream、outStream；</p><p>​    字符流：reader、writer；</p><p>3、按流的角色划分：节点流和处理流</p><p>​    Java l0流的40多个类都是从如下4个抽象类基类中派生出来的：</p><ul><li><code>InputStream/Reader</code>：所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>outputStream/writer</code>：所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul></blockquote><p><img src="01 JavaSE面试.assets/image-20220428105326455.png" alt="image-20220428105326455" style="zoom:50%;" /></p><p>&nbsp;<br></p><h4 id="11-简述序列化"><a href="#11-简述序列化" class="headerlink" title="11. 简述序列化"></a>11. 简述序列化</h4><blockquote><p>​    序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。</p><p>​    序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该流读取出来重新构造</p><p>成一个相同的对象。</p><p>​    序列化是通过实现Serializable接口，该接口没有需要实现的方法，implement Serialiable只是为了标注该对象是可被序列化的，</p><p>使用一个输出流（FileOutStream）来构造一个ObjectOutputStream对象，接着使用ObjectOutputStream对象的writeObject方法</p><p>就可以将参数的obj对象输出到磁盘，需要恢复的实话使用输入流。</p><p>​    ==序列化是将对象转换为容易传输的格式的过程，最主要的目的就是传递和保存对象，保存对象的完整性和可传递性==</p></blockquote><h4 id="12-简述Java序列化与反序列化的实现"><a href="#12-简述Java序列化与反序列化的实现" class="headerlink" title="12. 简述Java序列化与反序列化的实现"></a>12. 简述Java序列化与反序列化的实现</h4><blockquote><p>​    序列化：将java对象转化为字节序列，由此可以通过网络对象进行传输。</p><p>​    反序列化：将字节序列转化为java对象。</p><p>​    具体实现：实现 ==Serializable接口，==或实现 ==Externalizable接口== 中的 <code>writeExternal()</code> 与 <code>readExternal()</code> 方法。</p></blockquote><p>&nbsp;<br><br>&nbsp;<br></p><h2 id="chapter24-线程基础"><a href="#chapter24-线程基础" class="headerlink" title="chapter24 线程基础"></a>chapter24 线程基础</h2><h4 id="01-简述线程、程序、进程的基本概念以及之间关系"><a href="#01-简述线程、程序、进程的基本概念以及之间关系" class="headerlink" title="01. 简述线程、程序、进程的基本概念以及之间关系"></a>01. 简述线程、程序、进程的基本概念以及之间关系</h4><blockquote><p>​    线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。</p><p>​    与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>​    程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p>​    进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</p><p>​    系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>​    简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如：CPU时间、内存空间、文件、输入输出设备的使用权等等。、</p><p>​    换句话说，当程序在执行时，将会被操作系统载入内存中。线程是进程划分成的更小的运行单位。</p><p>​    线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</p><p>​    从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p></blockquote><p>&nbsp;<br></p><h4 id="02-简述进程和线程的区别"><a href="#02-简述进程和线程的区别" class="headerlink" title="02. 简述进程和线程的区别"></a>02. 简述进程和线程的区别</h4><blockquote><p>​    进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p><p><strong>线程与进程的区别归纳：</strong></p><ul><li>① ==地址空间和其它资源：==进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li><li>② ==通信：==进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信，需要进程同步和互斥手段的辅助，以保证数据的一致性。</li><li>③ ==调度和切换：==线程上下文切换比进程上下文切换要快得多。</li><li>④ 在多线程OS中，进程不是一个可执行的实体。</li></ul></blockquote><p>&nbsp;<br></p><h4 id="03-简述线程的基本状态"><a href="#03-简述线程的基本状态" class="headerlink" title="03. 简述线程的基本状态"></a>03. 简述线程的基本状态</h4><blockquote><p>​    ==新建(new)：==新创建了一个线程对象。</p><p>​    ==可运行(runnable)：==线程对象创建后，其他线程 (比如main线程) 调用了该对象的 <code>start()</code> 方法。</p><p>​    该状态的线程位于可运行线程中，等待被线程调度选中，获取cpu的使用权。</p><p>​    ==运行(running)：==可运行状态(runnable)的线程获得了cpu时间片 (timeslice)，执行程序代码。</p><p>​    ==阻塞(block)∶==阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。</p><p>​    直到线程进入可运行( runnable)状态，才有机会再次获得cpu timeslice转到运行(running )状态。</p><p>​    阻塞的情况分三种：</p><p>​    ① 等待阻塞：运行( running )的线程执行 <code>o.wait()</code>方法，JVM会把该线程放入等待队列(waitting queue)中。</p><p>​    ② 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lockpool)中。<br>​    ③ 其他阻塞：运行(running)的线程执行<code>Thread.sleep(long ms)</code>或<code>t.join()</code>方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者/O处理完毕时，线程重新转入可运行(runnable)状态。</p><p>​    ==死亡(dead)：==线程run()、main()方法执行结束,或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></blockquote><p><img src="01 JavaSE面试.assets/image-20220428105135519.png" alt="image-20220428105135519" style="zoom:50%;" /></p><p>&nbsp;<br><br>&nbsp;<br></p><h2 id="chapter25-反射"><a href="#chapter25-反射" class="headerlink" title="chapter25 反射"></a>chapter25 反射</h2><h4 id="01-简述Java反射机制"><a href="#01-简述Java反射机制" class="headerlink" title="01. 简述Java反射机制"></a>01. 简述Java反射机制</h4><blockquote><p>​    反射机制使得Java具有 ==动态获取程序信息和动态调用对象方法== 的能力。可以通过以下类调用反射API：</p><ul><li><p>Class类：获得类属性方法</p></li><li><p>Field类：获得类的成员变量</p></li><li><p>Method类：获取类的方法信息</p></li><li><p>Construct类：获取类的构造方法等信息</p></li></ul><p>​    在程序的运行过程中</p><ul><li>构造任意一个类的对象、</li><li>获取任意一个类的成员变量和成员方法、</li><li>获取任意一个对象所属的类信息、</li><li>调用任意一个对象的属性和方法。</li></ul></blockquote><p>&nbsp;</p><h4 id="02-简述Class对象"><a href="#02-简述Class对象" class="headerlink" title="02. 简述Class对象"></a>02. 简述Class对象</h4><blockquote><p>​    Java中对象可以分为 ==实例对象== 和 ==Class对象，==每一个类都有一个Class对象，其包含了与该类有关的信息。</p><p>​    获取Class对象的方法：</p><ul><li>类名.class</li><li>实例对象.getClass()</li><li>Class.forName(“类的全限定名”)</li><li>基本类型的包装类，可以调用包装类的Type属性来获得包装类的Class对象</li></ul></blockquote><p>&nbsp;</p><h4 id="03-简述Java实例化对象的方式"><a href="#03-简述Java实例化对象的方式" class="headerlink" title="03. 简述Java实例化对象的方式"></a>03. 简述Java实例化对象的方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 new</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 clone()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 反射机制</span></span><br><span class="line"><span class="comment">// 用 Class.forName方法获取类，在调用类的newinstance()方法</span></span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;com.dao.User&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) cls.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 序列化、反序列化</span></span><br><span class="line"><span class="comment">// 将一个对象实例化后，进行序列化，再反序列化，也可以获得一个对象(远程通信的场景下使用)</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span> (<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化对象</span></span><br><span class="line">out.writeObject(user1); </span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化对象</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/data.txt&quot;</span>));</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) in.readObject();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;反序列化user：&quot;</span> + user2);</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="04-简述Java反射机制优缺点"><a href="#04-简述Java反射机制优缺点" class="headerlink" title="04. 简述Java反射机制优缺点"></a>04. 简述Java反射机制优缺点</h4><blockquote><p>优点：</p><ul><li>能够运行时动态获取类的实例，提高灵活性；</li><li>与动态编译结合；</li></ul><p>缺点：</p><ul><li>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。解决方案：<ul><li>① 通过 <code>setAccessible(true)</code> 关闭JDK的安全检查来提升反射速度；</li><li>② 多次创建一个类的实例时，有缓存会快很多；</li><li>③ <code>ReflectASM</code>工具类，通过字节码生成的方式加快反射速度；</li></ul></li><li>相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性)</li></ul></blockquote><p>&nbsp;&nbsp;</p><h2 id="chapter26-注解"><a href="#chapter26-注解" class="headerlink" title="chapter26 注解"></a>chapter26 注解</h2><h4 id="01-简述注解"><a href="#01-简述注解" class="headerlink" title="01. 简述注解"></a>01. 简述注解</h4><blockquote><p>​    Java 注解用于为 Java 代码提供 ==元数据== ；</p><p>​    作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的；</p><p>​    其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作；</p></blockquote><p>&nbsp;</p><h4 id="02、简述元注解"><a href="#02、简述元注解" class="headerlink" title="02、简述元注解"></a>02、简述元注解</h4><blockquote><p>​    元注解可以理解为 ==注解的注解，==即在注解中使用，实现想要的功能。其具体分为：</p><ul><li><p><code>@Retention</code>：表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运行期（JVM中运行）</p></li><li><p><code>@Target</code>：表示注解作用的范围；</p></li><li><p><code>@Documented</code>：将注解中的元素包含到 Javadoc 中去；</p></li><li><p><code>@Inherited</code>：一个被@Inherited注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解；</p></li><li><p><code>@Repeatable</code>：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义；</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2</title>
      <link href="/2023/01/01/03-SpringBoot2/"/>
      <url>/2023/01/01/03-SpringBoot2/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql</title>
      <link href="/2023/01/01/04-MySql/"/>
      <url>/2023/01/01/04-MySql/</url>
      
        <content type="html"><![CDATA[<h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM</title>
      <link href="/2023/01/01/02-SSM/"/>
      <url>/2023/01/01/02-SSM/</url>
      
        <content type="html"><![CDATA[<h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2023/01/01/01-JVM/"/>
      <url>/2023/01/01/01-JVM/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE</title>
      <link href="/2023/01/01/01-JavaSE/"/>
      <url>/2023/01/01/01-JavaSE/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/01/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇文章</title>
      <link href="/2023/01/01/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/01/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第二篇文章"><a href="#第二篇文章" class="headerlink" title="第二篇文章"></a>第二篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三篇文章</title>
      <link href="/2023/01/01/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/01/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第三篇文章"><a href="#第三篇文章" class="headerlink" title="第三篇文章"></a>第三篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四篇文章</title>
      <link href="/2023/01/01/%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/01/%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第四篇文章"><a href="#第四篇文章" class="headerlink" title="第四篇文章"></a>第四篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<!-- GitCalendar容器 --><div id="gitZone"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[:root {    --trans-light: rgba(255, 255, 255, 0.80);    --trans-dark: rgba(25, 25, 25, 0.80);    --border-style: 1px solid rgb(169, 169, 169);    --backdrop-filter: blur(8px) saturate(150%);}/* 页脚与头图透明 */#footer {    background: transparent !important;}#page-header {    background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {    background: transparent !important;}#page-header::before {    background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}/* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {    background: #1e1e1e;    color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {    background: #3ecdf1;    color: #f2f2f2;}/* 一级菜单居中 */#nav .menus_items {    position: absolute !important;    width: fit-content !important;    left: 50% !important;    transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {    display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {    left: -38px;}/* 夜间模式菜单栏发光字 */[data-theme="dark"] #nav .site-page,[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li a {    text-shadow: 0 0 2px var(--theme-color) !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {    text-shadow: 0 0 2px var(--theme-color) !important;}/* 闪烁变动颜色连续渐变 */#site-name,#site-title,#site-subtitle,#post-info,.author-info__name,.author-info__description {    transition: text-shadow 1s linear !important;}/* 翻页按钮居中 */#pagination {    width: 100%;    margin: auto;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content>.card-widget.card-info {    background: linear-gradient(-45deg,            #e8d8b9,            #eccec5,            #a3e9eb,            #bdbdf0,            #eec1ea);    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@-moz-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content>.card-widget.card-info {    background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content>.card-widget.card-info>#card-info-btn {    background-color: #3eb8be;    border-radius: 8px;}/* 鼠标样式 */#cursor {    position: fixed;    width: 16px;    height: 16px;    /* 这里改变跟随的底色 */    background: rgb(57, 197, 187);    border-radius: 8px;    opacity: 0.25;    z-index: 10086;    pointer-events: none;    transition: 0.2s ease-in-out;    transition-property: background, opacity, transform;}#cursor.hidden {    opacity: 0;}#cursor.hover {    opacity: 0.1;    transform: scale(2.5);    -webkit-transform: scale(2.5);    -moz-transform: scale(2.5);    -ms-transform: scale(2.5);    -o-transform: scale(2.5);}#cursor.active {    opacity: 0.5;    transform: scale(0.5);    -webkit-transform: scale(0.5);    -moz-transform: scale(0.5);    -ms-transform: scale(0.5);    -o-transform: scale(0.5);}/* 首页文章卡片 */#recent-posts>.recent-post-item {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 25px;    border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 18px;    border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border: var(--border-style);    border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {    background: rgba(255, 255, 255, 0.75);    backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {    background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts>.recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {    background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {    background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {    background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;}[data-theme="dark"] .read-mode div#post {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe {    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) { }    return "";};class Cursor {    constructor() {        this.pos = { curr: null, prev: null };        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(57, 197, 187)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = { curr: null, prev: null };        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove = e => { (this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = { x: e.clientX - 8, y: e.clientY - 8 }; this.cursor.classList.remove("hidden"); };        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown = e => this.cursor.classList.add("active");        document.onmouseup = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[var now = new Date;function createtime() {    now.setTime(now.getTime() + 1e3);    var e = new Date("08/01/2022 00:00:00"),        t = Math.trunc(234e8 + (now - e) / 1e3 * 17),        a = (t / 1496e5)            .toFixed(6),        o = new Date("08/09/2022 00:00:00"),        n = (now - o) / 1e3 / 60 / 60 / 24,        r = Math.floor(n),        i = (now - o) / 1e3 / 60 / 60 - 24 * r,        s = Math.floor(i);    1 == String(s)        .length && (s = "0" + s);    var d = (now - o) / 1e3 / 60 - 1440 * r - 60 * s,        l = Math.floor(d);    1 == String(l)        .length && (l = "0" + l);    var g = (now - o) / 1e3 - 86400 * r - 3600 * s - 60 * l,        b = Math.round(g);    1 == String(b)        .length && (b = "0" + b);    let c = "";    c = s < 18 && s >= 9 ? `<img class='boardsign' src='https://sourcebucket.s3.ladydaily.com/badge/F小屋-科研摸鱼中.svg' title='什么时候能够实现财富自由呀~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>` : `<img class='boardsign' src='https://sourcebucket.s3.ladydaily.com/badge/F小屋-下班休息啦.svg' title='下班了就该开开心心地玩耍~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>`, document.getElementById("workboard") && (document.getElementById("workboard")        .innerHTML = c)}setInterval((() => {    createtime()}), 1e3);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/light.js"/>
      <url>/js/light.js</url>
      
        <content type="html"><![CDATA[// 霓虹灯效果// 颜色数组var arr = ["#39c5bb", "#f14747", "#f1a247", "#f1ee47", "#b347f1", "#1edbff", "#ed709b", "#5636ed"];// 颜色索引var idx = 0;// 切换颜色function changeColor() {    // 仅夜间模式才启用    if (document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark') {        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = arr[idx] + " 0 0 10px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = arr[idx] + " 0 0 5px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = arr[idx] + " 0 0 12px";            document.getElementsByClassName("author-info__description")[0].style.textShadow = arr[idx] + " 0 0 12px";        } catch {        }        idx++;        if (idx == 8) {            idx = 0;        }    } else {        // 白天模式恢复默认        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = "#1e1e1ee0 1px 1px 1px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = "";            document.getElementsByClassName("author-info__description")[0].style.textShadow = "";        } catch {        }    }}// 开启计时器window.onload = setInterval(changeColor, 1200);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() { window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; var n, e, i, h, t = .05, s = document.getElementById("universe"), o = !0, a = "180,184,240", r = "226,225,142", d = "226,225,224", c = []; function f() { n = window.innerWidth, e = window.innerHeight, i = .216 * n, s.setAttribute("width", n), s.setAttribute("height", e) } function u() { h.clearRect(0, 0, n, e); for (var t = c.length, i = 0; i < t; i++) { var s = c[i]; s.move(), s.fadeIn(), s.fadeOut(), s.draw() } } function y() { this.reset = function () { this.giant = m(3), this.comet = !this.giant && !o && m(10), this.x = l(0, n - 10), this.y = l(0, e), this.r = l(1.1, 2.6), this.dx = l(t, 6 * t) + (this.comet + 1 - 1) * t * l(50, 120) + 2 * t, this.dy = -l(t, 6 * t) - (this.comet + 1 - 1) * t * l(50, 120), this.fadingOut = null, this.fadingIn = !0, this.opacity = 0, this.opacityTresh = l(.2, 1 - .4 * (this.comet + 1 - 1)), this.do = l(5e-4, .002) + .001 * (this.comet + 1 - 1) }, this.fadeIn = function () { this.fadingIn && (this.fadingIn = !(this.opacity > this.opacityTresh), this.opacity += this.do) }, this.fadeOut = function () { this.fadingOut && (this.fadingOut = !(this.opacity < 0), this.opacity -= this.do / 2, (this.x > n || this.y < 0) && (this.fadingOut = !1, this.reset())) }, this.draw = function () { if (h.beginPath(), this.giant) h.fillStyle = "rgba(" + a + "," + this.opacity + ")", h.arc(this.x, this.y, 2, 0, 2 * Math.PI, !1); else if (this.comet) { h.fillStyle = "rgba(" + d + "," + this.opacity + ")", h.arc(this.x, this.y, 1.5, 0, 2 * Math.PI, !1); for (var t = 0; t < 30; t++)h.fillStyle = "rgba(" + d + "," + (this.opacity - this.opacity / 20 * t) + ")", h.rect(this.x - this.dx / 4 * t, this.y - this.dy / 4 * t - 2, 2, 2), h.fill() } else h.fillStyle = "rgba(" + r + "," + this.opacity + ")", h.rect(this.x, this.y, this.r, this.r); h.closePath(), h.fill() }, this.move = function () { this.x += this.dx, this.y += this.dy, !1 === this.fadingOut && this.reset(), (this.x > n - n / 4 || this.y < 0) && (this.fadingOut = !0) }, setTimeout(function () { o = !1 }, 50) } function m(t) { return Math.floor(1e3 * Math.random()) + 1 < 10 * t } function l(t, i) { return Math.random() * (i - t) + t } f(), window.addEventListener("resize", f, !1), function () { h = s.getContext("2d"); for (var t = 0; t < i; t++)c[t] = new y, c[t].reset(); u() }(), function t() { document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark' && u(), window.requestAnimationFrame(t) }() };dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
